### B树
截至目前我们讨论的日志结构的索引越来越被接受，然而它们不是最常见类型的索引。使用最广泛的索引结构完全是另外一个东西：B树。

1970年推出并在之后不到10年的时间里“无处不在”，B树非常好地经受住了时间的考验。几乎在所有的关系型数据库中它仍然是标准的索引实现，而许多非关系型数据库也用它。

就像SSTable一样，B树保存按键排序的键值对，这使得键值对查找以及范围查询非常有效率。但是相似的地方也就这么多：B树有着完全不一样的设计哲学。

我们之前了解的日志结构的索引把数据库拆分成大小不定的*段*，一般大小在几个MB甚至更多，并且段总是顺序写入的。相比之下，B树把数据库拆分成了固定大小的*块*或者*页*，习惯上大小是4KB（有些时候会更大一些），并且同时只读或写一个页。这种设计更贴近底层硬件，因为磁盘也是以固定大小的块进行排列的。

每一个页用地址或者位置标记，这使得页可以指向其它页——与指针类似，但是是在磁盘上而不是在内存中。我们可以用这些页引用构建页面树，如图3-6所示。

*图3-6 用B树索引查找键*

一个页被指定为B树的*根*；每当在索引中查找键的时候，都是从这里开始的。这个页包含了数个键与指向子页的引用。每一个子页覆盖一个连续区间的键，引用之间的键指明了覆盖区间的上下界。

在图3-6的例子中，我们在查找键251，于是知道我们需要沿着上下界为200与300的页引用查找。它把我们带到了一个相似的页面，它进一步把200到300区间分成了数个子区间。最终我们会下到包含独立键的页（叶子页），在那里要么包含内联键对应的值要么包含可以找到值的页引用。

B树中一个页包含的子页引用数被叫做*分支因子*。举个例子，在图3-6中分支因子为6。在实践中，分支因子受页引用的大小以及范围上下界的影响，但是通常是几百。

如果要更新B树中一个已有键对应的值，那么查找包含那个键的叶子页，修改这个页中值，然后把页写回磁盘中（任何指向这个页的引用依旧有效）。如果要添加一个新键，需要找到包含这个新键的区间所在的页然后把它添加进去。如果页没有足够的空间容纳新的键，那么把它分为两个半满的页，而父页也需要被更新以体现区间的重新划分——见图3-7。

*图3-7 通过分页使B树增长*

整个算法保证了树一直保持*平衡*：有着*n*个键的B树高度总是*O(log n)*。大多数数据库都可以放到一个三或四层高的B树里，所不需要为了找到你要的页访问很多页引用。（一个四层高的、每个页4KB、分支因子为500的树可以储存高达256TB的数据。）

#### 让B树变得可靠
B树的基本底层写入操作是用新数据覆盖磁盘上的页。这是基于复写不会改变页的位置的假设的；比如，所有指向这个页的引用在页被覆盖的时候保持不变。这与日志结构的索引形成鲜明的对比，日志结构索引只是附加数据到文件（并且最终删除废弃的文件）但是从来不会就地修改文件。

你可以把覆盖磁盘上的页当作实际的硬件操作。在一个磁盘上，这意味着移动磁头到正确的位置，等待磁盘旋转到正确的位置，之后用新数据覆盖合适的扇区。在固态硬盘上，发生的情况要更复杂一些，，因为固态硬盘必须一次擦除并重新写入存储芯片中的很大一块。

此外，一些操作需要好几个不同的页被复写。举个例子，如果插入动作导致页面需要被分成两部分，这需要写入两个页，并且重写父页以更新这两个子页的引用。这是一个危险的操作，因为如果数据库在其中一部分页被写入后崩溃，这时的索引就被破坏了（比如出现了一个不是任何页面子页的孤页）。

为了使数据库适应崩溃，通常B树的实现会包含一个额外的数据结构在磁盘上：*预写入日志*（WAL，也被称为*重做日志*）。这是一个只附加文件，每个对B树的改动都必须先被写入到这个文件然后再应用到树中的页上。当数据库从崩溃恢复，这个日志用来把B树恢复到一个一致的状态。

就地更新页带来的另一个复杂问题是如果多个线程同时访问B树就需要谨慎的并发控制——否则线程访问树会得到不一致的结果。一般是通过*锁存器*（轻量锁）保护树的数据结构解决这个问题。基于日志结构的方式再这个方面要简单一些，因为所有的合并动作是在后台完成而不会影响对系统的查询同时不时地原子化交换新旧段。

#### B树的优化
由于B树已经存在了太长时间，这些年来有许多优化方法被开发出来也不奇怪。这里只提几个：
* 相比于覆盖页并出于崩溃恢复的原因维护WAL，某些数据库（比如LMDB）使用了写入时复制方案。被修改的页写入到了另外一个位置，同时在树中创建了一个新的父页并指向它。这种方式对并发控制也很有用，这会出现在“快照隔离与重复读取”一节。
* 可以通过不存储整个键而是键的缩写来节省页内的空间。尤其是在树的上层，键只需要提供足够作为边界的信息就可以了。把更多的键存在同一个页使得树有更大的分支因子，因而有更少的层。
* 一般地，也可以被放在磁盘上地任何位置；并没有要求相邻的键区段在磁盘上的位置也靠近。如果一个查询需要以排序顺序扫描很大一部分键，那么分页布局就很没效率了，因为每个页的读取可能都需要磁盘重新寻址。许多B树的实现因此都尝试在布局时让叶子页以顺序次序出现在磁盘上。然而随着树的增长维护这个次序会变难。相比之下，LSM树在合并时只重写存储段一次，对它们来说保持顺序的键在磁盘上的位置也靠近会更简单一些。
* 额外的指针被添加到了树中。举个例子，每个叶子页可以有指向左右兄弟页的引用，使得按顺序扫描键不需要再跳回父页。
* B树的变种，比如*分形树*，为了减少磁盘寻址借鉴了某些日志结构的理念（而这与分形无关）。

### 比较B树与LSM树