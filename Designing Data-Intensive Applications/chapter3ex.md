### B树
截至目前我们讨论的日志结构的索引越来越被接受，然而它们不是最常见类型的索引。使用最广泛的索引结构完全是另外一个东西：B树。

1970年推出并在之后不到10年的时间里“无处不在”，B树非常好地经受住了时间的考验。几乎在所有的关系型数据库中它仍然是标准的索引实现，而许多非关系型数据库也用它。

就像SSTable一样，B树保存按键排序的键值对，这使得键值对查找以及范围查询非常有效率。但是相似的地方也就这么多：B树有着完全不一样的设计哲学。

我们之前了解的日志结构的索引把数据库拆分成大小不定的*段*，一般大小在几个MB甚至更多，并且段总是顺序写入的。相比之下，B树把数据库拆分成了固定大小的*块*或者*页*，习惯上大小是4KB（有些时候会更大一些），并且同时只读或写一个页。这种设计更贴近底层硬件，因为磁盘也是以固定大小的块进行排列的。

每一个页用地址或者位置标记，这使得页可以指向其它页——与指针类似，但是是在磁盘上而不是在内存中。我们可以用这些页引用构建页面树，如图3-6所示。

*图3-6 用B树索引查找键*

一个页被指定为B树的*根*；每当在索引中查找键的时候，都是从这里开始的。这个页包含了数个键与指向子页的引用。每一个子页覆盖一个连续区间的键，引用之间的键指明了覆盖区间的上下界。

在图3-6的例子中，我们在查找键251，于是知道我们需要沿着上下界为200与300的页引用查找。它把我们带到了一个相似的页面，它进一步把200到300区间分成了数个子区间。最终我们会下到包含独立键的页（叶子页），在那里要么包含内联键对应的值要么包含可以找到值的页引用。

B树中一个页包含的子页引用数被叫做*分支因子*。举个例子，在图3-6中分支因子为6。在实践中，分支因子受页引用的大小以及范围上下界的影响，但是通常是几百。

如果要更新B树中一个已有键对应的值，那么查找包含那个键的叶子页，修改这个页中值，然后把页写回磁盘中（任何指向这个页的引用依旧有效）。如果要添加一个新键，需要找到包含这个新键的区间所在的页然后把它添加进去。如果页没有足够的空间容纳新的键，那么把它分为两个半满的页，而父页也需要被更新以体现区间的重新划分——见图3-7。

*图3-7 通过分页使B树增长*

整个算法保证了树一直保持*平衡*：有着*n*个键的B树高度总是*O(log n)*。大多数数据库都可以放到一个三或四层高的B树里，所不需要为了找到你要的页访问很多页引用。（一个四层高的、每个页4KB、分支因子为500的树可以储存高达256TB的数据。）

#### 让B树变得可靠
B树的基本底层写入操作是用新数据覆盖磁盘上的页。这是基于复写不会改变页的位置的假设的；比如，所有指向这个页的引用在页被覆盖的时候保持不变。这与日志结构的索引形成鲜明的对比，日志结构索引只是附加数据到文件（并且最终删除废弃的文件）但是从来不会就地修改文件。

你可以把覆盖磁盘上的页当作实际的硬件操作。在一个磁盘上，这意味着移动磁头到正确的位置，等待磁盘旋转到正确的位置，之后用新数据覆盖合适的扇区。在固态硬盘上，发生的情况要更复杂一些，，因为固态硬盘必须一次擦除并重新写入存储芯片中的很大一块。

此外，一些操作需要好几个不同的页被复写。举个例子，如果插入动作导致页面需要被分成两部分，这需要写入两个页，并且重写父页以更新这两个子页的引用。这是一个危险的操作，因为如果数据库在其中一部分页被写入后崩溃，这时的索引就被破坏了（比如出现了一个不是任何页面子页的孤页）。

为了使数据库适应崩溃，通常B树的实现会包含一个额外的数据结构在磁盘上：*预写入日志*（WAL，也被称为*重做日志*）。这是一个只附加文件，每个对B树的改动都必须先被写入到这个文件然后再应用到树中的页上。当数据库从崩溃恢复，这个日志用来把B树恢复到一个一致的状态。

就地更新页带来的另一个复杂问题是如果多个线程同时访问B树就需要谨慎的并发控制——否则线程访问树会得到不一致的结果。一般是通过*锁存器*（轻量锁）保护树的数据结构解决这个问题。基于日志结构的方式再这个方面要简单一些，因为所有的合并动作是在后台完成而不会影响对系统的查询同时不时地原子化交换新旧段。

#### B树的优化
由于B树已经存在了太长时间，这些年来有许多优化方法被开发出来也不奇怪。这里只提几个：
* 相比于覆盖页并出于崩溃恢复的原因维护WAL，某些数据库（比如LMDB）使用了写入时复制方案。被修改的页写入到了另外一个位置，同时在树中创建了一个新的父页并指向它。这种方式对并发控制也很有用，这会出现在“快照隔离与重复读取”一节。
* 可以通过不存储整个键而是键的缩写来节省页内的空间。尤其是在树的上层，键只需要提供足够作为边界的信息就可以了。把更多的键存在同一个页使得树有更大的分支因子，因而有更少的层。
* 一般地，也可以被放在磁盘上地任何位置；并没有要求相邻的键区段在磁盘上的位置也靠近。如果一个查询需要以排序顺序扫描很大一部分键，那么分页布局就很没效率了，因为每个页的读取可能都需要磁盘重新寻址。许多B树的实现因此都尝试在布局时让叶子页以顺序次序出现在磁盘上。然而随着树的增长维护这个次序会变难。相比之下，LSM树在合并时只重写存储段一次，对它们来说保持顺序的键在磁盘上的位置也靠近会更简单一些。
* 额外的指针被添加到了树中。举个例子，每个叶子页可以有指向左右兄弟页的引用，使得按顺序扫描键不需要再跳回父页。
* B树的变种，比如*分形树*，为了减少磁盘寻址借鉴了某些日志结构的理念（而这与分形无关）。

### 比较B树与LSM树
虽然B树的实现一般比LSM树的实现更成熟，然而由于性能特点LSM树仍然很有趣。根据经验，LSM树一般写入更快，而B树被认为是读取更快的。在LSM树上读取一般会更慢是因为它们需要在不同的压缩阶段检查好几个不同的数据结构以及SSTable。

然而，基础测试经常是没有定论的，并且对具体的工作量很敏感。为了得到合理的比较结果，你需要用特定的工作量来测试系统。在这一节中我们将简要讨论在测试存储引擎性能时值得考虑的几件事。

#### LSM树的优势
B树索引每一份数据的写入都至少发生两次：一次写入到预写入日志，另一次写入到树中的页本身（如果需要分页的话那就再多一次）。每次都要写入一整页也产生开销，哪怕只是页中的几个字节改变了。某些存储引擎甚至会复写同一个页两次从而避免在类似断电的情况下得到一个部分被更新的页。

日志结构的索引也会因为重复的压缩合并SSTable而重写好几次数据。这个效应——在整个数据库生命期内每一次写入导致了数次的磁盘写入——被称为*写入放大*。在固态硬盘上是一个特别值得关注的问题，因为每一个区块只有有限的复写次数。

在写入繁重的应用中，性能瓶颈也许是数据库写入磁盘的速率。在这种情况下，写入放大有直接的性能代价：存储引擎写磁盘的次数越多，在可用的磁盘带宽下每秒能处理的写入次数就越少。

此外，相比于B树，LSM树通常可以维持高写入吞吐量，部分是因为有些时候它们有着较低的写入放大系数（然而这取决于存储引擎配置与工作量），部分是因为它们顺序写入压缩的SSTable文件而不是复写书中的部分页。在机械硬盘上这个差别特别重要，因为顺序写入比随机写入快多了。

LSM树可以被压缩得更好，因而相比于B树常常在磁盘上生成更小的文件。B树搜索引擎由于碎片会留下一些未用空间：当页面拆分或者一个行不能在已有页放下时，页中的某些空间没有被占用。因为LSM树不是基于页的而且定期重写SSTable以移除碎片，所以有着较低的存储代价，尤其是在用了分层压缩之后。

在许多固态硬盘中，固件内部使用了日志结构算法把随机写入变成底层存储芯片的顺序写入，于是存储引擎写入模式的影响不太明显。然而，较低的写入放大以及较少的碎片仍然是固态硬盘的优势：以更紧凑的方式表示数据使得在可用的输入/输出带宽内允许有更多的读取和写入请求。

#### LSM树的缺点
日志结构存储的一个缺点是压缩过程有时影响正在进行的读取和写入的性能。虽然存储引擎尝试执行增量压缩并且不影响并行访问，但是磁盘的资源有限，于是很容易发生请求需要等待磁盘完成代价昂贵的压缩操作。对吞吐量以及平均响应时间的影响一般比较小，但是在高百分位（见“描述性能”一节）查询日志结构存储引擎的相应时间有些时候会相当得高，而换作B树的话就更好预测一些。

另一个压缩的问题伴着高写入吞吐量产生：磁盘有限的的写入带宽需要在初始写入（记日志以及清空内存表到磁盘上）与后台运行的压缩线程之间共享。当写入一个空的数据库时，所有的磁盘带宽都可以被用来进行初始写入，但是随着数据库越来越大，更多的带宽被用于压缩。

如果写入吞吐量很高而且压缩配置不仔细的话，是会发生压缩跟不上写入速率的情况的。在这样的情况下，磁盘上没有被合并的段数量持续增长，直至磁盘空间耗尽，而读取也会因为需要检查更多的文件而被拖慢。通常，基于SSTable地存储引擎不会限制写入地速率，哪怕压缩无法跟上，所以你需要明确地监控以检测这种情况。

B树的一个优势是在索引中每个键只存在于一个位置，而日志结构的存储引擎可以在多个不同段中有数个同一个键的拷贝。这一方面使得B树在想要提供强大的事务语义的数据库中很有吸引力：在血多关系型数据库中，事务隔离是通过在键的区间上使用锁实现的，而在B树索引中，这些锁可以直接用于树。在第七章中我们会更详细地讨论这一点。

在数据库架构中B树已经相当根深蒂固了，并且针对多种级别工作量提供了一致好的性能，所以短时间内它不可能消失。在新的数据存储中，日志结构索引变得越来越流行了。没有快速简便的法则来判断那种存储引擎更适合你的场景，所以这值得凭经验测试一下。

### 其它索引结构
截至目前我们只讨论了键值对索引，它与关系型模型中的*主键*索引。主键唯一标识了关系型表中的一行，或者是文档型数据库中的一篇文档，或者是图数据库中的一个顶点。数据库中的其它条目可以通过这个主键（或者ID）引用那一行/一篇文档/一个顶点，而索引是用来解析这样的引用的。

*副键*也是很常见的。在关系型数据库中，你可以通过命令`CREATE INDEX`在同一张表中创建数个副键，为了使连接执行得有效率它们通常是必要的。举个例子，在第二章中的图2-1中你很有可能为`user_id`一列创建副键从而可以在每张表中找到所有属于同一个用户的行。

副键是很容易从键值索引中构建的。主要的差别在于键不唯一；即有可能许多行（文档，顶点）有着相同的键。有两种方式可以解决这个问题：要么让所以索引中的每一个值都是一个匹配行标识符的列表（类似全文索引中的TODO: posting list），要么通过附加行标识符使每个键都是唯一的。任意一种方式，B树与日志结构的索引都可以被用作副索引。