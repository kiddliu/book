# 第三章 存储与获取

*Wer Ordnung hält, ist nur zu faul zum Suchen*

（如果你喜欢保持事物整齐有序，你只是太懒不想去寻找罢了）

德国谚语

---

从最基础的层次来讲，数据库需要做两件事：当你给它某些数据，它应该存储这些数据，并且稍后当你问它这些数据时，它应该把数据给回你。

在第二张中我们讨论了数据模型和查询语言——比如，你（应用开发者）给数据库数据的格式，以及稍后问它再要回来的机制。在这一章我们讨论同样的东西，只是从数据库的角度出发：我们如何存储给定的数据，以及当我们被要求提供它时如何找到它。

为什么你，作为一个应用开发者，应当关心数据库内部是如何处理存储与获取的呢？你大概不会从头开始实现自己的存储引擎，但是你*确实*需要从一众可用选择中挑出适合你应用的存储引擎。为了让存储引擎在你的工作负载上运行出色，你需要对当前工作的存储引擎有一个粗略的概念。

特别的是，**为事务性负载优化的存储引擎与为分析优化的存储引擎是有很大差别的**。稍后在“事物处理还是分析？”一节探索这个差别，而在“面向列的存储”一节我们将讨论为分析优化的一个存储引擎家族。

然而，首先我们将通过讨论我们熟悉的数据库种类所使用的存储引擎开启这一章：传统的关系型数据库，以及大部分的NoSQL数据库。我们会查看储存引擎的两个家族：*日志结构*的存储引擎，以及*面向页*的存储引擎，比如B树。

## 为数据库助力的数据结构
想象一下世界上最简单的数据库，由两个Bash函数实现：
```Shell
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```
这两个函数实现了一个键值对存储。你可以调用`db_set key value`，把`key`与`value`储存在数据库中。键与值（几乎）可以是你想要的任何事物——举个例子，值可以是一个JSON文档。之后你可以调用`db_get key`，它会查找这个键绑定的最新的值并返回它。

而它确实可以工作的：
```Shell
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'
$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'
$ db_get 42
```
底层存储格式非常简单：一个文本文件，每一行包含一个键值对，用逗号隔开（大致与一个CSV文件类似，除了转义字符问题）。每一个`db_set`调用把值附加在文件结尾处，所以加入你更新某个键对应的值好几次，旧版本的值没有被覆盖——你需要查找文件中键出现的最后一次从而定位到最新的值（也就是`db_get`中的`tail -n 1`）：
```Shell
$ db_set 42 '{"name":"San Francisco","attractions":["Exploratorium"]}'

$ db_get 42
'{"name":"San Francisco","attractions":["Exploratorium"]}'

$ cat database
123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'
42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'
42 '{"name":"San Francisco","attractions":["Exploratorium"]}'
```
我们的`db_set`函数实际上对简单的事物有着相当不错的性能，因为附加到一个文件通常是非常有效率的。与`db_set`的行为类似，许多数据库在内部使用*日志*，一个只能附加的数据文件。真实的数据库有更多的问题要解决（比如并发控制、回收磁盘空间从而日志大小不会永远增长下去、以及处理错误与部分写入的条目），但是基本原则是一样的。日志出人意料的有用，在书的余下部分我们还会遇到它们几次。

> 注意
>
> *日志*这个词经常用于指代应用程序日志，那是应用程序输出描述发生了什么的文本。本书使用了*日志*更一般的含义：一个只追加的条目序列。它不必是人类可读；它也许是二进制的，只是为了让其它程序读取。

另一方面，如果在我们的数据库中有大量条目，我们的`db_get`函数性能会非常差。每一次要查找一个键，`db_get`都要从头到尾扫描整个数据库文件，查找键的出现。用算法术语的话，一次查询的代价是`O(n)`:如果数据库中的条目数`n`翻倍，那么查找也要花掉双倍的时间。这可不妙。

为了有效率地在数据库中查找特定地键，我们需要一个不一样地数据结构：*索引*。在这一章我们将看到一系列的索引结构并比较它们；它们背后的大概概念是另外保留某些额外的元数据作为路标，并帮助你定位到你想要的数据。如果你要用集中不同的方式搜索同一个数据，你也许需要几种由不同部分数据构成的索引。

索引是由主数据衍生出来的*额外的*数据结构。许多数据库允许添加和移除索引，而这并不影响数据库的内容；它只影响查询的性能。维护多余的数据结构导致额外的开销，尤其是在写入的时候。对写入来说，要击败只是附加内容到文件的性能是很难的，因为那就是最简单的写入操作。任何类型的索引通常都会使写入变慢，因为每次数据写入时都需要更新索引。

在数据系统中这是很重要的权衡：精心挑选的索引使读取查询更快，但是每一个索引都会使写入变慢。由于这个原因，数据库默认不为所有数据创建索引，而是要求你——应用开发者或是数据库管理员——手动选择索引，这需要借助你对应用的典型查询模式的理解。这样你可以选择带给应用最大便利的索引，而不必引入不必要的开销。