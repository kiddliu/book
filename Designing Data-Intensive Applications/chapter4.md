# 第四章 编码与演化

*世事皆变，无有静止*

以弗所的赫拉克利特，柏拉图在克堤拉斯篇引用的

---

应用程序不可避免地随时间而改变。因为新产品发布、用户需求的理解更加深入或者商业环境的改变，功能被添加被更改。在第一章中我们介绍了可进化性：我们应该着眼于构建可以轻松引入变更的系统（详见“可进化性：使变更变得简单”）。

在大多数情况下，应用功能的变更也需要对存储的数据变更：也许需要获取一个新的字段或者新的记录类型，也许也有数据需要以一种新的方式表达。

我们在第二章讨论的数据模型有不一样的方式应对这种变化。关系型数据库一般假设数据库中的所有数据符合一个模式定义：虽然这个模式定义可以改变（通过模式迁移；比如，`ALTER`语句），但是在任何一个时间点都只有一个模式定义生效。相比之下，只读模式（“无模式”）大数据不强制要求一个模式定义，所以数据库可以包含不同时间写入的新旧数据格式（见“文档模型中的模式定义灵活性”一节）。

当数据格式或是模式定义变化的时候，对应的应用代码也会发生变化（比如，为记录添加一个新字段，然后应用程序代码读写这个字段）。然而，在一个大的应用中，代码变化不会立即发生：

* 对服务器应用程序你大概想要执行*滚动升级*（也叫做*分阶段推出*），一次部署新版到一部分节点，检查新版本是不是平稳运行，然后逐步部署到所有的节点。这使得新版本的部署没有离线，因而估计更频繁的发布以及更好的演进。

* 对于客户端应用程序，您可能会受到用户的摆布，他们可能不会在一段时间内安装更新。

这意味着新旧版本代码，以及新旧版本的数据格式，很可能同一时间存在于系统中。为了使系统继续平稳运行，需要同时在两个方向保持兼容性：

*向后兼容*

新代码可以读取旧代码写入的数据。

*向前兼容*

旧代码可以读取新代码写入的数据。

向后兼容通常并不难实现：作为新代码的作者，你知道旧代码写入的数据格式，于是你可以显式处理它（如果必要只是让旧代码读取旧数据）。向前兼容会复杂一些，因为它需要旧代码忽略新代码带来的添加。

在这一章我们会了解几种数据编码的格式，包括JSON、XML、Protocol Buffers、Thrift以及Avro。特别的是，我们会了解它们是如何处理模式变更以及如何支持新旧数据与新旧代码需要共存的系统。然后我们会讨论这些格式是如何用于数据存储以及通讯的：在web服务中，具象状态传输（REST）与远程过程调用（RPC），以及消息传递系统，比如参与者与消息队列。

## 数据编码的格式

程序通常使用（至少）两种表现形式的数据：

1. 在内存中，数据以对象、结构体、链表、数组、哈希表、树等形式保存。这些数据结构都为CPU的高效访问与处理优化（一般通过使用指针）了。

2. 把数据写入文件或者通过网络发送的时候，必须把它编码为某种自成体系的字节序列（比如，JSON文档）。由于指针对其它进程没有任何意义，这个字节序列形式与内存中常见的数据结构非常不同。

因而，我们需要两种表现形式之间的转换方式。从内存表现形式转为字节序列叫做*编码*（也叫做*序列化*或者*编组*），相反的处理叫做*解码*（*解析，反序列化，反编组*）。

> ##### 术语冲突
>
> 不幸的是*序列化*在事务中（见第七章）也用到了，但是有完全不同的含义。为了避免重载这个词我们将在本书中继续使用*编码*这个词，即使*序列化*也许是更常见的术语。

由于这是一个常见问题，因此可以选择多种不同的库和编码格式。让我们来做一个简要的概述。

### 编程语言特有的格式
