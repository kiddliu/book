# 第七章 事务

*有些作者声称一般性的二阶段提交支持起来代价太大，因为它带来了性能或者可用性问题。我们认为让应用程序开发者处理由于过度使用事务而出现瓶颈的性能问题会更好，而不应该在编程时完全没有事务可用。*

詹姆斯·科贝特等，*Spanner：谷歌的全球级分布式数据库*（2012）

---

数据系统的残酷现实世界中，很多东西都可能会出错：

* 数据库软件或是硬件可能在任何时间崩溃（包括在一次写入过程当中）。

* 应用程序可能在任何时间崩溃（包括在执行一系列操作的中途）。

* 网络中断可以意外地将应用程序从数据库断开，或者把一个数据库节点与另外一个节点断开。

* 数个客户端可以同时写入数据库，覆盖彼此提交的变更。

* 客户端会读取到没有意义的数据，因为先前只被部分地更新了。

* 客户端之间的竞争条件可以导致以外的bug。

为了可靠，系统需要处理这些故障并且保证它们不会导致整个系统灾难性的故障。然而，实现容错机制需要大量的工作。它需要对所有可能出错的事进行仔细的考虑，以及大量的测试从而保证解决方案是实际可行的。

数十年来，*事务*都是简化这些问题的首选机制。事务是应用程序把数个读写请求组合为一个逻辑单元的方式。从概念上讲，事务中的所有读写操作执行时被当作一次操作：整个事务要么成功（*提交*）要么失败（*取消*，*回滚*）。如果失败，应用可以安全地重试。有了事务，错误处理对应用程序来说变得相当简单，因为它不再需要担心部分失败——也就是（无论出于任何原因）某些操作成功了而某些失败了的情况。

如果你已经有了使用事务许多年的经验，它们看起来很浅显，但是我们不应该视它们为理所应当。事务不是一条自然规则；它们被发明出来是有目的的，就是为了在应用程序访问数据库时*简化编程模型*。通过使用事务，应用程序可以自如地忽略某些潜在的错误场景以及并发问题，因为数据库会替你处理它们（我们把这叫做*安全性保证*）。

不是所有的应用程序都需要用到事务，有些时候弱化事务性保证或是干脆完全抛弃它也是有好处的（比如，为了实现更高的性能或是更高的可用性）。某些安全属性是可以不通过事务实现的。

那么如何判断你需不需要事务呢？为了回答这个问题，我们首先需要理解到底事务可以提供什么样的安全性保证，以及随之而来的代价是什么。虽然乍一看事务简单明了，但是实际上有很多细微但是重要的细节在起作用。

在这一张，我们会研究许多会出错的事情，并且探索数据库用来针对这些问题的算法。我们会特别深入到并发控制的领域，讨论可能发生的各种种类的竞争条件以及数据库是如何实现比如*提交读*、*快照隔离*以及*可串行化*这样的隔离界别的。

这一章既适用于单节点数据库也适用于分布式数据库；在第八章我们将着重讨论只在分布式系统中出现的难题。

## 事务难以掌握的概念

今天，几乎所有的关系型数据库，以及一些非关系型数据库，都支持事务。它们中的绝大多数都沿用第一款SQL数据库，IBM System R在1975年引入的风格。虽然某些实现细节发生了变化，但是总体思路在40年内基本保持不变：MySQL、PostgreSQL、Oracle、SQL Server等对事务的支持与System R的惊人地相似。

在2000年代末，非关系型（NoSQL）数据库开始变得流行起来。它们旨在通过提供新的数据模型来改善关系性数据库的现状（见第二章），并且默认包含了复制（见第五章）以及分区（见第六章）。事务是这场运动的主要受害者：许多新一代的数据库完全放弃了事务，或者重新定义了这个次用以描述比先前所理解的要弱得多的一套保证。

围绕着对这一类新的分布式数据库的炒作，出现了一种普遍的看法，就是事务是站在可扩展性的对立面的，任何大型系统都必须放弃事务从而维持良好的性能和高可用性。另一方面，事务性保证有时被数据库厂商呈现为“有价值数据”的“严肃的应用程序”的基本要求。

事实可没有那么简单：就像任何其它技术设计选择一样，事务也有优点与限制。为了理解这些权衡，让我们看看事务可以提供的保证的细节——无论是在正常运行还是各种极端的（却也现实）的情况之下。

### ACID的含义

事务提供的安全性保证常常用知名的缩写ACID描述，它代表了*原子性*、*一致性*、*隔离性*和*持久性*。它由Theo Härder和Andreas Reuter于1983年创造，旨在为数据库中的容错机制建立精确的术语。

然而，在现实中，一个数据库的ACID实现与另外一个的实现并不等同。举个例子，之后我们会看到，关于*隔离*的含义就有许多歧义。在高层次的理念合理的，但是问题处在了细节上。今天，当一个系统号称“符合ACID”，实际上尚不清楚有哪些保证。ACID非常不幸地变成了一个商业用词。

（不满足ACID标准地系统有时被称作BASE，它代表了*基本可用*、*软状态*以及*最终一致性*，这比ACID的定义还要模糊。看起来BASE唯一合理的定义是“非ACID”；也就是说它可以意味着任何事。）

让我们深入研究原子性、一致性、隔离性和持久性的定义，因为这会让我们改进我们对事务的理解。

#### 原子性

通常，*原子性*指的是无法分割成更小部件的东西。这个词在计算机学不同的分支内指代的是相似但又稍微不同的东西。举个例子，在多线程编程中，如果一个线程执行原子操作，那意味着另外一个线程没有办法看到这个操作一半的结果。系统只会要么处于操作之前的状态或者操作之后的状态，而不是介于二者之间。

相比之下，在ACID的上下文中，原子性与并发*无关*。它也不是描述如果几个进程同时访问同一个数据会发生什么，因为那是字母*I*涵盖的，即*隔离性*（详见“隔离性”一节）。

相反的事，ACID原子性描述的是当客户端想要进行数个写入请求，但是在某些写入请求处理结束后发生了故障时——比如，进程崩溃，网络连接中断，磁盘写满，或者是违反了某些完整性约束——会发生什么。如果写入请求被归为一个原子事务，而事务由于故障不能完成（*提交*），那么事务会*中止*，而数据库必须丢弃或者复原任何迄今为止事务完成的写入。

没有原子性，如果在进行多次更改的过程中发生错误，那么很难知道哪些变化已经生效而哪些没有。应用可以再次尝试写入，但是写入同样变更两次带来的分线，会导致重复或是不正确的数据。原子性简化了这个问题：如果事务被中止，应用程序可以确定它没有改变任何东西，所以它可以安全地重试。

ACID原子性的定义特征是能够在出错的时候放弃事务并把所有事务的写入放弃。相比于*原子性*来说也许*可取消性*是一个更好的词，但是我们会继续用*原子性*，因为那才是常用词。

#### 一致性

*一致性*这个词已经被重用地太厉害了：

* 在第五章我们讨论了*复制一致性*，以及异步复制系统中出现的*最终一致性*问题（见“复制延迟的问题”一节）。

* *一致性哈希*是某些系统用于再平衡的分区方法。（见“一致性哈希”）。

* 在CAP定理中（见第九章），*一致性*一词是用来指*可线性化*（见“可线性化”）。

* 在ACID的语境下，*一致性*指的是一种应用程序特定的概念——数据库目前处于“良好的状态”。

* In the context of ACID, consistency refers to an application-specific notion of the database being in a “good state.”

同一个词用来表达至少四种不同的含义实在是不幸。

ACID一致性的理念是关于数据的某些描述（不变量）必须始终为真——举个例子，在账户系统中，所有账户的借贷必须平衡。如果事务起始时数据库满足那些不变量，而事务处理期间的任何写入都保持有效性，那么可以确定不变量还是满足的。

然而，这种一致性的理念取决于应用程序的不变量定义，正确定义事务使得它们保持一致性。这也是应用程序的责任。这不是数据库可以保证的：如果你写入了错误的数据破坏了这些不变量，数据库也不能阻止你。（某些特定种类的不变量可以由数据库检查，比如使用外键限制或是唯一性限制。然而通常，引用程序定义哪些数据合法哪些数据不合法——数据库只负责存储它们。）

原子性、隔离性和持久性是数据库的特性，而一致性（在ACID意义上）是应用程序特性。应用程序依赖数据库的原子性与隔离性来实现一致性，但是这不只取决于数据库。因而，字母C其实不属于ACID。

#### 隔离性

大多数数据库可以同时为多个客户端访问。如果它们读写的是数据库不同的部分那是没问题的，然而如果它们访问的是同一个数据库条目，就会碰到并发问题（竞争条件）。

图7-1是这种问题的一个简单示例。假设有两个客户端在持续递增存储在数据库中的计数器值。每个客户端需要读取当前的值，增加1，然后把新值写回去（假设数据库没有内建递增操作）。在图7-1中计数器应该从42增加到了44，因为发生了两次递增，但是由于竞争条件实际上只到了43。

ACID意义上的隔离性是指并发执行的事务相互之间是隔离的：它们不会互相干预彼此的操作。经典数据库教科书把隔离性形式化为可串行化性，意味着每个事务都可以假装自己是整个数据库上唯一正在执行的事务。数据库保证在事务提交之后，结果与它们顺序执行（一个接一个）的结果是一样的，哪怕实际上它们是并发执行的。

*图7-1. 两个并发递增计数器的客户端之间的竞争条件。*

然而在实际当中，可串行化的隔离性很少用到，因为它会带来性能损失。一些流行的数据库，比如Oracle 11g，根本没实现它。在Oracel数据库中有一个隔离界别叫做“可串行化”，但是实际上实现的是*快照隔离*，相比可串行化它是一个弱保证。我们会在“弱隔离级别”一节中探索快照隔离以及其它形式的隔离。

#### 持久性

数据库系统存在的目的是为了提供一个安全的储存数据的场所而不用担心丢失它。持久性承诺一旦事务提交成功，它写入的任何数据不会被遗忘，哪怕是发生了硬件故障或是数据库崩溃了。

在单节点数据库中，持久性通常意味着数据库已经被写入到诸如机械硬盘或是固态硬盘这样的非易失性存储中。它常常也涉及到预写入日志或是类似的东西（见“让B树变得可靠”一节），它在磁盘上的数据结构被破坏之后可以进行恢复。在一个复制数据库中，持续性意味着数据被成功地复制到了一定数量的节点。为了保证持久性，数据库必须等待所有的写入或是复制完成以后才能报告事务成功地提交了。

就如“可靠性”一节讨论到地，完美地持久性是不存在的：如果所有的硬盘与所有的备份同时被破坏了，显然没有什么数据库可以帮到你的了。

> **复制与持久性**
>
> 历史上，持久性是指写入到备份磁带上。之后被理解为写入到磁盘或是固态硬盘。最近，它开始意味着复制。那种实现更好呢？
>
> 事实是，没有什么是完美的：
>
> * 如果写入到了磁盘而设备死掉了，虽然数据没有丢失，但是直到你修复了设备或是把磁盘转移到另一台设备，数据都是无法访问的。复制了的系统则继续可用。
>
> * 相关性故障——断电或是由于特定输入导致所有节点崩溃的bug——可以立刻让所有副本下线（见“可靠性”一节），丢失任何还在内存中的数据。因此对于内存数据库来说，写入到磁盘仍然是相关的操作。
>
> * 在异步复制系统中，当领机离线时最新的写入请求都会丢失（见“处理节点离线”一节）。
>
> * 当电源突然被掐断，固态硬盘尤其表现出有时会违反它们本应提供的保证：哪怕`fsync`也无法保证工作正常。硬盘固件会有bug，就像任何其它类型的软件一样。
>
> * 存储引擎与文件系统实现之间的细微互动可以导致很难跟踪的bug，并会导致磁盘上的文件在崩溃后被破坏。 
>
> * 磁盘上的数据会慢慢地不知不觉地被破坏。如果数据被破坏已经有了一段时间，副本以及最新地备份也可能已经破坏了。在这种情况下，你需要尝试从一份老的备份中恢复数据。
>
> * 一份关于固态硬盘的研究发现在使用的头四年中产生至少一个坏块的可能性在30%到80%。机械硬盘相比于固态硬盘有更低的坏扇区率，但是有更高的完全故障率。
>
> * 如果SSD被断电，在几个礼拜之内就会开始丢失数据，而它取决于温度。
>
> 在实践中，没有任何一种技巧可以提供绝对的保证。只有各种降低风险的技巧，包括写入到磁盘，复制到远端设备以及备份——且它们可以也应该一起使用。与往常一样，用怀疑的眼光看待任何理论性的“保证”总是明智的。

### 单对象与多对象操作

概括一下，在ACID中，原子性与隔离性描述了在同一个事务中如果客户端发起了几个写入请求数据库应该做什么：

*原子性*

如果在执行一系列写入中途发生了错误，事务应当中止，而已经完成了的写入应当被丢弃。换句话说，数据库通过提供全有或者全无的保证，使你不用担心发生部分故障。

*隔离性*

并发执行的事务不应该互相干预彼此。举个例子，如果一个事务发起了数个写入请求，之后的另一个事务应该要么看到所有的写入，要么什么都没看到，但是不会看到其中一部分。

这些定义都假设你一次要修改数个对象（行，文档，记录）。如果好几份数据需要保持同步的话就经常需要这种*多对象事务*。图7-2展示了一个来自电子邮件应用的例子。为了显示用户未读邮件的数量，你会进行类似这样的查询：

```SQL
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true
```

然而，如果邮件太多你会发现这个查询太慢了，于是决定把未读消息的数量储存在一个单独的字段里（一种反规范化）。现在，每当收到一封新邮件，你也必须为未读计数器加一，而每当一封邮件被标记为已读，你也必须为唯独计数器减一。

在图7-2中，用户2经历了一个异常现象：邮箱列表显示有一封未读邮件，但是因为计数器加一还没发生，计数器显示零个未读邮件。隔离性可以通过保证用户2要么同时看到插入的邮件和更新了的计数器，要么什么都没有，而不是一个不一致的中间状态来预防这个问题。

*图7-2 违反隔离性：一个事务读到了另一个事务未提交的写入（“脏读”）。*

图7-3展示了对原子性的需要：如果在事务的过程中发生了错误，邮箱的内容与未读计数器就变得不同步了。在一个原子性事务中，如果对计数器的更新失败了，事务会终止且被插入的邮件会回滚。

*图7-3 原子性保证如果发生了错误任何来自事务之前的写入都会被撤销，以避免不一致的状态。*

多对象事务需要某些方式判定哪些读写操作属于同一个事务。在关系型数据库中，这通常是基于客户端到数据库服务器的TCP连接完成的：在任意特定的连接上，在`BEING TRANSACTION`与`COMMIT`之间的所有语句被认为属于同一个事务。

另一方面，许多非关系型数据库没有这种把操作分组到一起的方式。即使有多对象的API（举个例子，键值对存储可以有一次操作更新好几个键值的*多赋值*操作），但是这不意味它有事务的语义：这个命令有可能成功更新了某些键值而其它的失败了，使数据库出在了部分更新的状态。

#### 单对象写入

当单对象被更新时原子性与隔离性也适用。举个例子，假设你正在写入20KB大的JSON文档到数据库：

* 如果网络连接在发送10KB之后中断了，数据库会存储这无法解析的10KB JSON片段么？

* 如果数据库正在覆盖磁盘上的前一个值时断电了，你最终得到的是新旧值拼接在一起的值么？

* 如果另一个客户端在写入进行时读取那个文档，它看到的是一个部分更新的值么？

这些问题会令人难以置信地困惑，所以存储引擎几乎普遍提供单节点上的单对象（比如键值对）级别的原子性与隔离性。原子性在针对崩溃恢复时可以用日志实现（见“使B树稳定”一节），而隔离性可以用每个对象的锁来实现（同一时刻只允许一个线程访问对象）。

一些数据库孩提攻了更复杂的原子操作，比如增量操作，它消除了对如图7-1所示的读取-修改-写入循环的需求。类似的流行操作还有比较并设置操作，它使得写入只有在值没有并发地被其它人修改才会发生（见“比较并设置”一节）。

这些单对象操作很有用，因为它们可以防止好几个客户端并发尝试写入同一个对象时丢失更新的数据（见“防止丢失更新的数据”）。然而，它们不是通常意义上的事务。比较并设置以及其它单对象操作由于商业目的已经被称为“轻量级事务”，甚至是“ACID”，但是这些术语都是误导人的。事务通常被理解为一种把在多个对象上的多个操作分组成单个操作单元的机制。

#### 多对象事务的需要

许多分布式数据存储放弃了多对象事务，因为在多分区上实现很困难，而且在某些需要非常高的可用性和性能的场景中会很碍事。然而，本质上没有任何东西阻拦分布式数据库使用事务，我们会在第九章讨论分布式事务的实现。

但是我们到底需不需要多对象事务呢？只用键值对数据模型和单对象操作是不是就可以实现任意的应用程序呢？

某些使用场景中单对象插入、更新、删除就足够了。然而在许多其他场景中我们需要协调对好几个不同对象的写入操作：

* 在关系型数据模型中，一张表中的一行经常有一个指向其它表中一行的外键。（类似的在图数据模型中，一个顶点有到其它顶点的边。）多对象事务允许你保证这些引用保持有效：当插入几条互相指向的记录，那外键必须正确而且保持更新，否则数据就没有意义了。

* 在文档型数据模型中，需要被一起更新的字段经常是在同一个文档里的，它们被视为单个对象——在更新单个文档是不需要多对象事务。然而，文档型数据库没有连接功能，也鼓励反规范化（见“今天关系型 vs 文档型数据库”一节）。当反规范化的信息需要更新时，比如图7-2中的例子，你需要一次更新好几个文档。事务在这种场景下非常有用，防止非规范化的数据不同步。

* 在有二级索引的数据库（几乎所有数据库都有，除了纯键值对存储）中，每当你更新一个值时索引也需要更新。从事务的角度上看这些索引是不同的数据库对象：举个例子，没有事务隔离性，一条记录出现在一个索引中但是不在另外一个索引中是可能的，因为对第二个索引的更新还没有发生。

这样的应用程序仍然可以不用事务实现。然而没有原子性的话错误处理变得非常复杂，没有隔离性则会导致并发问题。我们会在“弱隔离级别”一节讨论这些问题，并在第十二章探索其它替代方案。

#### 处理错误与中止

事务的一个核心功能是当错误发生时他可以被终止然后安全地重试。符合ACID地数据库是基于这样的哲学地：如果数据库面临原子性、隔离性或者持久性被破坏的危险，它宁愿放弃整个事务也不会允许它部分执行。

然而并不是所有的系统都遵从这个哲学。特别是，无领机复制的数据库（见“无领机复制”一节）更多的是基于“尽最大努力”信条，它可以被总结为“数据库会尽可能地执行语句，当遇到问题时，他不会撤销它已经完成了的结果”——所以从错误中恢复编程了应用程序的责任。

错误的发生难以避免，但是许多软件开发者更倾向于只考虑不出错的路径而不是复杂的错误处理。举个例子，非常流行的对象关系映射（ORM）框架，比如Rail的ActiveRecord以及Django，不会重试中止了的事务——错误通常引发堆栈异常，所以任何用户输入都被丢弃而用户获得一条错误信息。这很可惜，因为中止的全部意义就是为了可以安全的重试。

虽然重试中止了的事务是一个既简单又有效的错误处理机制，但是它并不完美：

* 如果事务实际成功了，但是服务器试图向服务器确认提交成功时网络瘫痪了（于是客户端认为它失败了），那么再次事务重试会导致它被执行两次——除非你已经有了另外一个应用级别的去重机制。

* 如果错误是因为负载过高，重试事务会导致问题更加严重，而不会更好。为了避免这种反馈循环，你可以限制重试的次数，使用指数回退，并且（可能的话）把负载过高相关错误的处理机制与其它的区别开来。

* 只有在发生了瞬态错误（比如说死锁、违反了隔离性、临时网络中断以及故障迁移）之后才值得重试；而发生了永久错误（比如违反了约束）之后重试是没有意义的。

* 如果事务还会导致数据库之外的副作用，即使事务被中止了这些副作用也许已经发生了。举个例子，如果你再发送电子邮件，你不会想要在重试事务时每次重新发送这封电子邮件。如果你想要确定好几个不同的系统要么一起提交或者中止了事务，两段提交可以有所帮助（我们会在“原子提交与两段提交（2PC）”一节中讨论它）。

* 如果客户端进程在重试时崩溃，它尝试写入到数据库的任何数据都会丢失。