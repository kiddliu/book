* 如果副本分布在数个数据中心（为了从地理位置上更接近用户，或者是为了高可用性），就更增进了复杂性。任何需要领机服务的请求都必须首先发送到包含领机的数据中心。

当同一个用户从多个设备，比如桌面网页浏览器和移动客户端，访问你的服务时另外一个复杂问题出现了。在这种情况下你需要提供*跨设备的*写入后读取一致性：如果用户在一台设备上输入了某些信息然后再另外一台设备上浏览它，他们应该看到各个输入的信息。

在这种情况下，有几个额外的问题需要考虑：

* 那种需要记住用户最后一次更新的时间戳的方式变得更困难了，因为运行在一个设备上的代码不知道另一台设备上发生了什么样的更新。这个元数据需要中心化。

* 如果你的副本分布在不同的数据中心里，那么没有办法保证来自不同设备的连接会路由到相同的数据中心。（举个例子，如果用户的台式机使用家里的宽带连接而移动设备使用的是移动数据网络，那么设备的网路路由也许是完全不同的。）如果你的方法需要从领机读取，也许你首先需要吧来自用户设备的所有请求路由到同一个数据中心。

### 单调读取

从异步从机读取时可以发生的异常现象第二例，是用户有可能看到时间倒流了。

这种情况可以发生在用户尝试从不同的副本读取数据。举个例子，图5-4显示了用户2345发起两次同样的请求，第一个请求发送到了有少许延迟的从机，之后第二个发送到了有很大延迟的从机。（当用户刷新网页时这个场景很可能发生，每一个请求都发送到了一个随机服务器。）第一个查询请求返回了用户1234最近添加的一条评论，但是第二天查询请求并没有返回任何东西，因为延迟的从机还没有收到那条写入变更。实际上，相比于第一条查询请求第二条查询请求在一个更早的时间点观察系统。如果第一条查询请求没有返回任何东西这看起来不算太差，因为用户2345大概不知道用户1234最近添加了一条评论。然而，如果先看了用户1234的评论，之后又消失了，这会非常让用户2345困惑。

*图 5-4. 用户首先从更新了的副本读取，之后从旧的副本读取。时间看起来倒流了。我们需要单调读取来防止这种异常现象。*

*单调读取*保证了这一类异常情况不会发生。相比于强一致性它是一种弱保证，但是相比于最终一致性这是一种强保证。当读取数据时，你也许会看到一个旧的值；单调读取只意味着如果用户顺序发起了几个请求，他们不会看到时间倒流——也就是说，他们不会在之前读到新数据的情况下再读到旧数据。

实现单调读取的一种方式是保证每个用户都从同一个副本读取（不同的用户可以从不同的副本读取）。举个例子，副本的选择可以基于用户ID的哈希，而不是随机的。然而，如果那台副本故障了，用户的查询请求需要被重新路由到另外一台副本。

### 一致性前缀读取

复制延迟异常现象的第三个例子是关于因果关系违反的。设想下面一段Poons先生与Cake太太的对话

*Poons先生*

Cake太太，对于未来你能看多远？

*Cake太太*

通常大约十秒钟吧，Poons先生。

两句话之间有因果关系：Cake太太听到了Poons先生的问题并做出了回答。

现在，假设第三个通过从机再听这段对话。Cake太太说的话经过了一个有少许延迟的从机，但是Poons先生说的话有一个更长的复制延迟（见图5-5）。观察者会听到下面的对话：

*Cake太太*

通常大约十秒钟吧，Poons先生。

*Poons先生*

Cake太太，对于未来你能看多远？

对于观察者来说这看起来好像Cake太太正在回答Poons先生还没有问出口的问题。这种精神力量给人留下深刻印象，但是也会很困惑。

*图5-5 如果部分分库比其它的复制的慢，观察者会先看到答案再看到问题。*

避免这一类异常现象需要另一种类型的保证：一致性前缀读取。这种保证是说如果一系列写入以某种顺序发生，那么任何读取这些写入的人也会以同样的顺序看到这些写入。

这对于已分区的（已分片的）数据库来说是一个很特别的问题，我们会在第六章讨论它。如果数据库一致以同样的顺序应用写入动作，写动作会一直看到一致性前缀，于是这种异常不会发生。然而，在许多分布式数据库中，不同的分区独立地运行，所以没有写入地全局顺序的：当用户读取数据库时，他们会看到某些部分是旧的状态，而有一些已经是新的状态了。

一种解决方案是保证任何有因果关系的写入都去到了同一个分区——但是在一些应用中没有办法高效地完成。也有算法可以明确地保留因果关系记录，我们将在““之前发生”关系与并发”一节回到这个问题上。

### 复制延迟的解决方案

在使用最终一致系统时，很值得考虑一下当复制延迟上升到几分钟甚至几个小时的时候应用的行为如何。如果你的答案是“没问题”，这很好。然而，如果结果是用户体验很糟糕的话，为系统设计更强的保证，比如写入后的读取，是很重要的。假装复制是同步的但实际上是异步的注定会导致问题。

如前面所讨论的，应用程序相比于底层数据库提供更强的保证是有许多种方式的——举个例子，在领机上执行特定类型的读取。然而在应用程序代码中处理这些问题会很复杂并且很容易出错。

如果应用程序开发者不用考虑细微的复制问题而是相信数据库就可以“做正确的事”，那就更好了。这就是事务存在的原因：这是一种数据库提供更强保证的方式，于是应用变得更简单。

单节点事务已经存在很长时间，然而，在转向分布式（复制了的或者分区了的）数据库时，许多系统放弃了它，声称事务对于性能以及可用性来说都代价太高了，并且断言最终一致性在可扩展系统中是无法避免的。这段表述部分是事实，但是过于简单了，而我们会在本书的余下部分构建更细致入微的观点。我们会在第七、九章回到事务这个主题，而在第三部分讨论一些替代机制。