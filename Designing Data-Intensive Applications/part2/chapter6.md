# 第六章 分库

*显然，我们必须脱离顺序同时不去限制计算机。 我们必须声明定义并提供数据的优先级和描述。 我们必须说明关系，而不是过程。*

葛丽丝·穆雷·霍普, *未来的管理与计算机* (1962)

---

在第五章我们讨论了复制——也就是，在不同节点上有同样数据的多个拷贝。对于非常大的数据集，或者非常高的查询吞吐量，这是不够的：我们需要把数据*分区*，也叫做*分片*。

> 术语上的混乱
>
> 我们这里称之为*parition*的东西在MongoDB、Elasticsearch以及SolrCloud中叫做*shard*；在HBase叫做*region*，在Bigtable中叫做*tablet*，在Cassandra和Riak中叫做vnode，在Couchbase中叫做vBucket。然而，分区时最成熟的名词，所以我们会继续用它。

通常，分区时这样定义的，每条数据（每条记录，每个行或者每个文档）只属于一个分区。有许多方式可以实现这个目标，我们会在本章深入讨论它们。实际上，每个分区都是一个小数据库，虽然数据库支持同时涉及多个分区的操作。

想要对数据分区的主要原因是*可扩展性*。不同分区可以放在无共享集群中的不同的节点上（*无共享*的定义详见第二部分的介绍）。因而，大的数据集分布在多个磁盘，查询负载分布在多个处理器上。

对于在单个分区上操作的查询请求，每个节点可以在自己的分区上独立执行查询请求，所以查询吞吐量可以通过添加更多节点扩展。大型复杂的查询请求可以并行在多个节点上执行，虽然这样会变得非常困难。

分区数据库的先行者是1980年代的产品，比如Teradata和Tandem NonStop SQL，而最近被NoSQL数据库和基于Hadoop的数据仓库重新发现。有些系统为事务性工作量设计，而其它是为了分析（见“事务处理，还是分析？”一节）：这个差别影响了系统如何调优，但是分区的基本原理适用于两种工作负载。

在这一章中我们将首先了解大型数据集分区的不同方式，并观察为数据建立索引是如何与分区互动的。然后我们会聊到再平衡，如果你要添加或移除集群中的节点的话是很必要的。最后我们会概览数据库是如何路由请求到正确的分区而后执行查询请求的。