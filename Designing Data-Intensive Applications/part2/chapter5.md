# 第五章 副本

*一个可能出错的事物和一个不可能出错的事物之间的主要区别是，当一个不可能出错的事物出错时，通常没办法用也没办法修了。*

---

道格拉斯·亚当斯，*基本无害*（1992）

副本的意思是保存同一份数据的拷贝在数台通过网络连接的设备上。在第二部分的介绍中我们提到，想要复制数据有下面好几个原因：

* 让数据在物理位置上更靠近你的用户（因而降低了延迟）

* 即使在某些部分失效的情形下允许系统继续工作（因而增加了可用性）

* 增加了服务读取请求的设备数量（因而增加了读取吞吐量）

在这一章我们会假设你的数据集很小以至于单个设备就可以保存整个数据集的拷贝。在第六章我们会放开这个假设条件，讨论对单个设备太大的数据集的*分库*（*分片*）。在更后边的章节我们会讨论可以发生在复制的数据系统的各种不同种类的故障，以及如何处理它们。

如果复制的数据不会随时间变化，那么复制过程就很简单：你只需要把数据拷贝到各个节点，就这样。所有复制过程中的难题都发生在如何处理复制后数据的变化，这一章就是讲这些的。我们将讨论三种流行的节点间复制变更的算法：*单主机*，*多主机*，以及*无主机*复制。几乎所有的分布式数据库都使用这三种方式之一。它们都有各种优缺点，稍后我们会详细的研究。

副本有许多权衡需要考虑：觉个例子，用同步复制还是异步复制，如何处理失败的副本。它们通常是数据库中的可配置选项，尽管每个数据库细节都不一致，但是一般性的原则在众多不同的实现之间还是类似的。我们会在这一章讨论各种选择所带来的后果。

数据库副本是个旧话题——自1970年代被研究之后原则并没有太大的变化，因为网络的基础限制依然没变。然而在研究之外的地方，许多开发者很长一段时间继续假设数据库只包含一个节点。分布式数据库的主流应用是最近的事。由于许多应用开发者是该领域的新手，对类似*最终一致性*这样的问题一致有许多错误理解。在“TODO:副本延迟的问题”一节我们会更精确地了解最终一致性，并且讨论例如*读取你的写入*以及*单调读取保证*这样的问题。

## 领机与从机

每一个储存着数据库拷贝的节点叫做*副本*。有了多个副本，有个问题难免会有：我们如何保证数据拷贝到了所有的副本上？

每次对数据库的写入都需要被每一个副本处理；否则，副本不再包含着同一份数据了。最常见的解决方式叫做*基于领机的复制*（也叫做*主动/被动*或者*主从复制*），如图5-1所示。工作原理如下：

1. 副本之一被指定为领机（也叫做主机）。当客户端要写入数据库时，它们必须发送请求到领机，它首先把新数据写入到本地存储中。

2. 其它副本称为*从机*（*读取副本*，*从机*，*辅机*，或者*热待机*）。每当领机写入新数据到自己的本地存储，它也发送数据变更到它的所有从机，作为复制日志或者变更流的一部分。每个从机从领机获取日志并更新对应的本地数据库拷贝，它按照领机上处理的相同的顺序应用所有的写入操作。

3. 当客户端要读取数据库时，它既可以查询领机也可以查询任意从机。然而，写入只会被领机接受（从客户端的角度看，从机是只读的）。

*图5-1 基于领机的（主从）复制*

这种模式的复制是许多关系型数据库，比如PostgreSQL（自从9.0版本）、MySQL、Oracle Data Guard以及SQL Server的AlwaysOn Availability Groups的内建功能。它也被用在一些非关系型数据库中，包括了MongoDB、RethinkDB以及Espresso。最后，基于领机的复制并不只局限于数据库：分布式的消息代理例如Kafka以及RabbitMQ高可用队列也使用它。一些网络文件系统以及复制块设备比如（DRBD）也很类似。

