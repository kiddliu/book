# 第五章 副本

*一个可能出错的事物和一个不可能出错的事物之间的主要区别是，当一个不可能出错的事物出错时，通常没办法用也没办法修了。*

---

道格拉斯·亚当斯，*基本无害*（1992）

副本的意思是保存同一份数据的拷贝在数台通过网络连接的设备上。在第二部分的介绍中我们提到，想要复制数据有下面好几个原因：

* 让数据在物理位置上更靠近你的用户（因而降低了延迟）

* 即使在某些部分失效的情形下允许系统继续工作（因而增加了可用性）

* 增加了服务读取请求的设备数量（因而增加了读取吞吐量）

在这一章我们会假设你的数据集很小以至于单个设备就可以保存整个数据集的拷贝。在第六章我们会放开这个假设条件，讨论对单个设备太大的数据集的*分库*（*分片*）。在更后边的章节我们会讨论可以发生在复制的数据系统的各种不同种类的故障，以及如何处理它们。

如果复制的数据不会随时间变化，那么复制过程就很简单：你只需要把数据拷贝到各个节点，就这样。所有复制过程中的难题都发生在如何处理复制后数据的变化，这一章就是讲这些的。我们将讨论三种流行的节点间复制变更的算法：*单主机*，*多主机*，以及*无主机*复制。几乎所有的分布式数据库都使用这三种方式之一。它们都有各种优缺点，稍后我们会详细的研究。

副本有许多权衡需要考虑：觉个例子，用同步复制还是异步复制，如何处理失败的副本。它们通常是数据库中的可配置选项，尽管每个数据库细节都不一致，但是一般性的原则在众多不同的实现之间还是类似的。我们会在这一章讨论各种选择所带来的后果。

数据库副本是个旧话题——自1970年代被研究之后原则并没有太大的变化，因为网络的基础限制依然没变。然而在研究之外的地方，许多开发者很长一段时间继续假设数据库只包含一个节点。分布式数据库的主流应用是最近的事。由于许多应用开发者是该领域的新手，对类似*最终一致性*这样的问题一致有许多错误理解。在“TODO:副本延迟的问题”一节我们会更精确地了解最终一致性，并且讨论例如*读取你的写入*以及*单调读取保证*这样的问题。

## 领机与从机

每一个储存着数据库拷贝的节点叫做*副本*。有了多个副本，有个问题难免会有：我们如何保证数据拷贝到了所有的副本上？

每次对数据库的写入都需要被每一个副本处理；否则，副本不再包含着同一份数据了。最常见的解决方式叫做*基于领机的复制*（也叫做*主动/被动*或者*主从复制*），如图5-1所示。工作原理如下：

1. 副本之一被指定为领机（也叫做主机）。当客户端要写入数据库时，它们必须发送请求到领机，它首先把新数据写入到本地存储中。

2. 其它副本称为*从机*（*读取副本*，*从机*，*辅机*，或者*热待机*）。每当领机写入新数据到自己的本地存储，它也发送数据变更到它的所有从机，作为复制日志或者变更流的一部分。每个从机从领机获取日志并更新对应的本地数据库拷贝，它按照领机上处理的相同的顺序应用所有的写入操作。

3. 当客户端要读取数据库时，它既可以查询领机也可以查询任意从机。然而，写入只会被领机接受（从客户端的角度看，从机是只读的）。

*图5-1 基于领机的（主从）复制*

这种模式的复制是许多关系型数据库，比如PostgreSQL（自从9.0版本）、MySQL、Oracle Data Guard以及SQL Server的AlwaysOn Availability Groups的内建功能。它也被用在一些非关系型数据库中，包括了MongoDB、RethinkDB以及Espresso。最后，基于领机的复制并不只局限于数据库：分布式的消息代理例如Kafka以及RabbitMQ高可用队列也使用它。一些网络文件系统以及复制块设备比如（DRBD）也很类似。

### 同步复制 vs 异步复制

副本系统的一个重要细节是复制是*同步*发生的还是*异步*发生的。（在关系型数据库中，这通常是一个可配置选项；其它系统通常是硬编码为二者之一。）

考虑一下图5-1中发生了什么，其中的网站用户更新了他的资料图片。在某个时刻，客户端发送了更新请求到领机；稍后，请求被领机接受。再在某个时刻，领机把数据变更转发到从机。最终，领机通知客户端更新成功。

图5-2现实了系统众多组件之间的通信：用户的客户端，领机，以及两个从机。时间从左向右流逝。请求与响应消息是用粗箭头表示的。

*图5-2 基于领机的复制，其中一个同步从机一个异步从机*

在图5-2的势力中，复制到从机1是同步的：领机等待从机1直至从机1确认完成了写入动作之后才向用户报告成功，同时也才让写入对其他客户端可见。复制到从机2是异步的：领机发送消息，但是不会等待来自从机的响应。

图标显示了从机2处理消息之前有足够的延迟。通常，复制是相当快的：大多数数据库系统不到一秒钟就可以应用变更到从机。然而，并不能保证这个动作会花多长时间。有情况显示从机有可能落后于领机几分钟，甚至更多；举个例子，比如从机正在从故障中恢复，比如系统负载几乎为满，比如节点之间网络有问题。

同步复制的优势在于从机保证可以获得最新的、与领机一致的数据。如果领机突然崩溃，我们可以确定从机上的数据依然可用。缺点在于同步从机如果不响应（由于崩溃，或者网络故障，或者任何其他原因），写入将不能继续处理。领机必须阻塞所有的写入，直至同步副本再次可用。

因为这样的原因，那么所有的从机都是同步的就不现实了：任意节点离线都会导致整个系统陷于停顿。实践中，如果为数据库启用了同步复制，这通常意味着只有一个从机是同步的，而其他从机都是异步的。如果同步从机不可用或者变慢，可以把一个异步从机变为同步的。这保证了最新的数据至少出现在两个节点上：领机与一个同步从机。这种配置被叫做*半同步*。

很多时候，基于领机的复制是被配置成完全异步的。在这种情况下，如果领机故障也无法恢复的花，任何没有复制到从机的写入都会丢失。这意味着写入是无法保证的，哪怕客户端已经确认了。然而，完全异步配置也有优势，领机可以一致处理写入请求，哪怕所有的从机都落后于领机。

削弱耐久性听起来像是一个馊主意，但是异步复制仍然被广泛使用，尤其是有许多从机，或者从机分布在不同的地方。我们会在“复制延迟带来问题”一节回到这个问题上。

> 关于复制的研究
>
> 对于异步复制系统来说领机崩溃导致的数据丢失是一个很严重的问题，于是研究者依然在探索不会导致数据丢失但仍然提供良好性能于可用性的复制方法。比如，*链式复制*是同步复制的一个变种，已经成功应用在了类似微软Azure Storage这样的部分系统中了。
>
> 复制的一致性与共识（让好几个节点同意某个值）之间有很强的联系，我们会在第九章更详细地探索这个领域的理论。在这一章我们会集中在哪些实践中数据库上最长用到的简单复制形式上。

### 设置新的从机

时不时，你需要设置新的从机——也许是为了增加副本的数量，或者是替换崩溃的节点。你如何保证新的从机有着与领机一模一样的数据？

只是把数据从一个节点拷贝到另一个节点通常是不够的：客户端在持续地写入数据库，数据一直在变化，那么标准的文件拷贝在不同的时间点会看到数据库的不同部门。这样的结果没有任何意义。

你可以通过锁住数据库（从而无法写入）使磁盘上的文件一致，但是这违背了我们追求高可用性的目标。幸运的是，设置从机通常不会产生离线时间。定义上的流程是这样的：

1. 获取某个时间点的领机数据库的一致性快照——如果可能的话，不锁整个数据库。大多数数据库有这个功能，因为备份也是需要它的。在某些情况下，还需要第三方工具，例如MySQL的*innobakcupex*。

2. 把快照拷贝到新从机节点。

3. 从机连接到主机并请求所有发生在快照截取之后的数据变更。这要求快照绑定到了领机复制日志中的一个精确位置。这个位置有许多个名字：举个例子，PostgreSQL把它叫做*日志序列号*，而MySQL把它叫做*二进制日志坐标*

4. 当从机处理了自快照起积压的数据变更后，我们说它*赶上来*了。这是可以继续并开始处理来自领机的刚刚发生的数据变更。

设置从机的实际步骤由于数据库而非常不同。在某些系统中这个过程是全自动的，而在其它的里边它可以是某种神秘的多步骤工作流，需要管理员手动执行。

## 处理节点离线

系统中的任意节点都可以下线，也是是因为意外的故障，或者只是因为到了事先计划好的维护时间（举个例子，重启设备以安装内核安全补丁）。可以重启独立节点而不造成停机对于运维来说是巨大的优势。因此，我们的目标是保持系统作为一个整体运行良好而不在意个别节点崩溃，以为保持节点离线的影响越小越好。

对于基于领机的复制如何实现高可用性呢？

### 从机故障：追赶恢复

每一台从机在自己的本地磁盘上都保存了来自领机的数据变更的日志。如果从机崩溃然后重启，或者领机与从机之间的网络临时受阻，从机可以相当轻松的恢复：它从自己的日志知道故障发生钱最后一个被处理的事务。因而，从机可以连接到领机并请求自断线以后发生的所有数据变更。当这些变更应用完毕时，从机追赶上了领机并可以如往常一样接受数据变更流。

### 领机故障：故障迁移

处理领机故障更复杂一些：一台从机需要升级为新的领机，客户端需要重新配置才能发送写入请求到新的领机，同时其他从机需要开始处理来自新领机的数据变更。这个过程叫做*故障迁移*。

故障迁移可以手动触发（管理员接到领机故障的通知，采取必要措施构建新的领机）或者完全自动化。自动化故障迁移流程通常包含下面几步：

1. *判断领机故障*。许多事都有可能出错：系统崩溃，停电，网络问题，等等。没有简单明了的方式判断到底哪除了问题，所以绝大部分系统只是用了超时：节点频繁地在彼此之间来回传递消息，如果节点在一段时间内没有响应——比如说，30秒——我们就假设它崩溃了。（如果领机由于计划好的维护而估计下线的，就不适用了。）

2. *选择一个新领机*。这可以通过一个选举过程（领机由余下副本的大多数投票选择）解决，或者由先前指定的*控制器节点*指定新领机。最佳的备选通常是有着来自旧领机最新数据变更（把数据丢失风险降到最低）的副本。使所有节点都同意新领机是一个共识问题，会在第九章具体讨论。

3. *重新配置系统，使用新领机*。客户端现在需要发送它们的写入请求到新领机（会在“路由请求”一节讨论）。如果旧的领机恢复，它有可能还认为自己是领机，没有意识到其它副本强制它卸任了。系统需要保证旧领机变为从机，并且识别出新的领机。

故障迁移也注定有许多可能出错的事情：

* 如果使用了异步复制，新的领机可能在旧领机故障之前并没有接收到所有的写入。如果旧领机在新领机被选举出来之后重新加入到簇，这些写入怎么办呢？同时新领机也有可能收到冲突的写入。最常见的解决方案是旧领机丢弃没有被复制的写入，但是这样也许违背了客户端在持久性方面的预期。

* 如果数据库之外其它的存储系统需要与数据库内容协调的花，丢弃写入是极其危险的。举个例子，在GitHub的一次时间中，一个许久没有更新的从机被提升为领机。数据库使用了一个自增长的计数器给新插入的行分配主键，但是因为新领机的计数落后于旧领机的，于是重用了一些已经被旧领机分配过了的主键。这些主键也被用在了一个Redis存储中，主键的重用导致了MySQL与Redis之间不再保持一致，引发了某些私人数据暴露给了错误的用户。

* 在特定的故障场景（见第八章），两个节点都认为自己是领机的情况是会发生的。这种情况被叫做*脑裂*，这很危险：如果两个领机都接受写入请求，没有流程来处理冲突（见“多领机复制”一节），数据很有可能被丢失或者损坏。某些系统有机制在检测到两个领机后关闭其中一个节点。然而如果这个机制设计不是很细心的话，有可能最终两个节点都会被关闭。

在领机被宣布故障之前正确的超时是多少呢？超时时间更长意味着领机故障需要更长的时间恢复。然而如果超时过短，也可能发生不必要的故障迁移。举个例子，短时间负载高峰也许会让节点的响应时间超时，网络小故障也会导致包延迟。如果系统已经在高负载或是网络问题中苦苦挣扎，不必要的故障迁移极有可能使情况变得更糟，而不是更好。

这些问题都没有简单的解决方案。由于这个原因，某些运营团队更倾向于手动执行故障迁移，哪怕软件本身支持自动故障迁移。

这些问题——节点故障；不可靠的网络；以及副本一致性，持久性，可用性之间的权衡，以及延迟——实际上是分布式系统的基本问题。在第八和第九章我们会深度讨论它们。

### 复制日志的实现

基于领机的复制到底是如何工作的？实践中使用几种不同的复制方法，让我们简要了解一下每一种方法。

#### 基于语句的复制

在最简单的情况，领机记录每一个它执行地写入请求（语句），然后发送语句日志到它地从机。对于关系型数据库，这意味着每一个`INSERT`、`UPDATE`或`DELETE`语句都转发给了从机，每个从机解析并执行这个SQL语句如果它是直接来自客户端的。

虽然这听起来很合理，但是这种方式有许多种失败的可能：

* 任何语句调用非确定性函数，比如`NOW()`以获取当前日期与时间或者`RAND()`以获取随机数，在不同副本很有可能生成不同的值。

* 如果语句用到自增的列，或者是依赖数据库中已有的数据（比如，`UPDATE ... WHERE <some condition>`），他们在每一个副本上必须以完全一致的顺序执行，否则它们也许有不同的结果。当有多个并发执行的事务时，这会是很大的限制。

* 有副作用的语句（比如触发器，存储过程，用户定义函数）会在每一个副本上触发不同的副作用，除非副作用是绝对确定性的。

绕过这些问题是可能的——举个例子，领机可以在记录语句时用固定的返回值替换任何非确定性函数调用，从而所有从机都获得相同的值。然而，因为有许多边缘情况，其它复制方法现在通常更受欢迎。

MySQL在5.1版本之前使用基于语句的复制。今天依然有时在用，由于相当紧凑，但是如果语句中有任何不确定性默认的MySQL会切换到基于行的复制（稍后将讨论到）。VoltDB使用基于语句的复制，通过要求事务是确定性的使之安全。

#### 预写入日志（WAL）发送

在第三章我们讨论了存储引擎如何在磁盘上呈现数据，我们发现通常每一次写入都附加到了日志上：

* 对于日志结构的存储引擎（见“SSTable与LSM树”一节），这个日志是存储的主要位置。日志在后台被压缩并进行垃圾回收。

* 对于会复写独立磁盘块的B树（见“B树”一节），每一次修改首先被写入到预写入日志于是索引可以在崩溃之后恢复到一致的状态。

任一种情况，日志都是一个只附加的字节序列，包含着所有对数据库的写入。我们可以用一模一样的日志在另一个节点上构建副本：除了把日志写入到磁盘，领机也通过网络把它发送给从机。当从机处理这个日志时，它构建了领机上一模一样的数据结构拷贝。

这种复制方法被用在了PostgreSQL以及Oracle等等。主要的缺点是日志在一个非常低的层级描述数据：WAL细致地包含了哪个磁盘区块的哪个字节发生了变化。这使得复制与存储引擎紧密地耦合着。如果数据库把储存格式从一个版本变成了另外一个版本，通常在领机和从机上运行不同的数据库版本是不可能的。

这看起来好像只是一个很小的实现细节，但是运营时会有很大的影响。如果复制协议允许从机比领机更新的软件版本，你可以执行执行零离线时间的数据库软件升级：首先升级从机，然后执行故障迁移使其中一个从机变为领机。如果复制协议不允许这种版本不匹配，由于这是WAL发送常态，这样的升级需要离线时间。

#### 逻辑（基于日志的）日志拷贝

一种替代方案是为复制与存储引擎使用不同的日志格式，这样使得复制日志与存储引擎内部实现解耦。这种复制日志被叫做*逻辑日志*，用以区分存储引擎的（物理的）数据表示方法。

关系型数据库的逻辑日志通常是记录序列，以行的粒度描述对数据表的写入：

* 对于被插入的行，日志包含了所有列的新值。

* 对于被删除的行，日志包含了足够多的信息用来唯一标识被删除的行。通常这个信息是主键，但是如果表里没有主键，所有列的旧值都需要被记录。

* 对于被更新的行，日志包含了足够多的信息用来唯一标识被更新的行，还包括所有列的新值（或者至少是所有变了的行的新值）。 

一个修改了好几行的事务会生成好几个这样的日志记录，紧接着是一个指示事务已提交的记录。MySQL的二进制日志（当被配置为使用基于行的复制时）使用这个方式。

由于逻辑日志与存储引擎内部实现解耦，它很容易的保留了向后兼容性，允许领机与从机运行不同版本的数据库软件，甚至是不同的数据引擎。

逻辑日志格式也很容易被外部应用解析。如果向一个外部系统发送数据库内容，比如向数据仓库发送做离线分析，或者是为了构建自定义索引以及缓存，这一方面都是很有用的。这个技术叫做*数据变更抓取*，我们会在第十一章回到这个话题。

#### 基于触发器的复制

截至目前描述的复制方法都是数据库系统实现的，没有涉及到任何应用程序代码。在许多情况下，这就是你要的——但是也有一些场景需要更大的灵活性。举个例子，如果你只想复制一部分数据，或者从一种数据库复制到另一种数据库，或者你需要解决冲突的逻辑（见“处理写入冲突”一节），那么你也许需要把复制过程向上挪到应用层。

一些工具，例如Oracle GoldenGate，通过读取数据库日志使数据变更对应用程序可用。另外一个备选方案使使用在许多关系型数据库中都有的功能：*触发器*与*存储过程*。

触发器允许你注册自定义的应用程序代码，当数据库系统中数据变化的时候自动执行。触发器有机会把这个变更记录到单独一张表里，外部进程可以读取它。这个外部进程之后应用任意必要的引用逻辑然后把数据变更复制到其它系统。举个例子，针对Oracle的Databus与针对Postgres的Bucardo都是这样工作的。

相比于其它复制方法，基于触发器的复制通常有更大的消耗，相比于数据库内建的复制方法也更容易出问题，更容易受到限制。然而，它仍然因为灵活性而有用。

## 复制延迟带来的问题

可以容忍节点故障只是想要复制的一个原因。正如在第二部分的介绍中提到的，其他原因还包括可扩展性（处理超过单台设备可以应对的请求）以及延迟（把副本放置在地理位置更靠近用户的地方）。

基于领机的复制需要所有的写入请求发送到单个节点，但是只读查询请求可以发送到任何副本。由于工作负载绝大部分是读取而很小一部分是写入（网络上常见的模式），这里有一个吸引人的选项：建立许多从机，并把读取请求分发到这些从机去。这降低了领机的负载并且允许读取请求是由就近的副本服务的。

在这种按读取缩放的架构中，你可以通过只是添加更多从机来增加服务只读请求的容量。然而，这种手段只对异步复制实际有效——如果你尝试同步复制到所有的从机，单个节点故障或者是断网都会是整个系统写入不可用。而且节点越多，一个节点离线的可能性就越大，因而一个完全的同步配置是非常不可靠的。

然而，如果引用程序读自异步从机，如果从机落后的话它也许会看到过期的信息。这会导致数据库中明显的不一致：如果同时在领机与从机上执行一样的查询请求，你也许会得到不一样的结果，因为不是所有的写入请求都反映到了从机。这种不一致只是种临时状态——如果你停止写入到数据库然后等一小会儿，从机最终会赶上，与领机保持一致。由于这个原因，这个效果叫做*最终一致性*。

术语“最终”是故意模糊的：一般地，没有限制副本可以落后多少。在正常地运营下，从写入到领机到反映到从机之间的延迟——复制延迟——也许只是几分之一秒，实践中并不太容易注意到。然而如果系统运行在接近满负载的情况或者网络中有问题，延迟会很轻易地上升到几秒钟甚至几分钟。

当延迟很高的时候，产生的不一致性不再只是理论性的问题而是应用真实的问题。在这一节我们会着重研究三个示例问题，它们在有复制延迟的时候很有可能发生，并且列出解决它们的几个办法。

### 读取自己的写入

许多应用程序允许用户提交一些数据，然后显示他们刚刚提交的。这也许是客户数据库中的记录，讨论主题中的评论，或是其它类似的东西。当新数据被提交以后，它必须被发送到领机，但是当用户查看数据，它可能读自一台从机。如果数据被频繁地查看但是只是偶尔写入地话，这样就特别合适。

对于异步复制来说，这里有个问题，如图5-3所示：如果用户在数据写入后不久即浏览它，那么新数据也许还没有到达副本。对于用户，这看起来好像他们提交的数据丢失了，可以理解他们会不高兴的。

*图5-3 用户写入后紧接着从旧的副本读取。为了避免这样的异常现象，我们需要保持写入后读取一致性*

在这种情况下，我们需要*写入后读取一致性*，也叫做*读取自己的写入一致性*。这是一种保证，如果用户重新加载页面，他们总是可以看到他们自己提交的任意更新。这对其它用户没有任何承诺：其它用户的更新稍后才可见。然而，它向用户保证了它们自己的写入被正确保存了。

在一个基于领机的复制的系统中我们如何实现写入后读取一致性呢？仅举几例：

* 在读取用户可能修改了的数据时，从领机读取；否则，从从机读取。这要求你有办法在不实际查询的情况下知道数据是不是已经被修改了。举个例子，社交网络上的用户信息一般只允许用户自己修改，其它人是不可以的。因而，一个简单的规则是：总是从领机读取用户自己的用户信息，从从机读取任意其它人的用户信息。

* 如果应用程序中的大部分东西都是可以被用户修改的，那种方式就不是很有效了，因为大多数数据就必须从领机读取了（读取缩放的收效将大打折扣）。在这种情况，可以用其它标准决定是否从领机读取。举个例子，你可以追踪最后一次更新的时间，以及在最后一次更新之后的一分钟内都从领机读取。你也可以监控监控从机的复制延迟，拒绝对落后一分钟以上的从机发起查询请求。

* 客户端可以记住最近一次写入的时间戳——之后系统可以保证服务于那个用户的副本会返回截至于那个时间点前的所有更新。如果副本数据不足够新，要么读取请求可以由另外一个副本处理，要么查询请求可以等待副本更到最新。时间戳可以是逻辑时间戳（指示写入顺序的东西，比如日志序列号）或者是实际的系统时钟（在这种情况下时钟的同步问题变得关键起来；见“不可靠的时钟”一节）。

* 如果副本分布在数个数据中心（为了从地理位置上更接近用户，或者是为了高可用性），就更增进了复杂性。任何需要领机服务的请求都必须首先发送到包含领机的数据中心。

当同一个用户从多个设备，比如桌面网页浏览器和移动客户端，访问你的服务时另外一个复杂问题出现了。在这种情况下你需要提供*跨设备的*写入后读取一致性：如果用户在一台设备上输入了某些信息然后再另外一台设备上浏览它，他们应该看到各个输入的信息。

在这种情况下，有几个额外的问题需要考虑：

* 那种需要记住用户最后一次更新的时间戳的方式变得更困难了，因为运行在一个设备上的代码不知道另一台设备上发生了什么样的更新。这个元数据需要中心化。

* 如果你的副本分布在不同的数据中心里，那么没有办法保证来自不同设备的连接会路由到相同的数据中心。（举个例子，如果用户的台式机使用家里的宽带连接而移动设备使用的是移动数据网络，那么设备的网路路由也许是完全不同的。）如果你的方法需要从领机读取，也许你首先需要吧来自用户设备的所有请求路由到同一个数据中心。

### 单调读取

从异步从机读取时可以发生的异常现象第二例，是用户有可能看到时间倒流了。

这种情况可以发生在用户尝试从不同的副本读取数据。举个例子，图5-4显示了用户2345发起两次同样的请求，第一个请求发送到了有少许延迟的从机，之后第二个发送到了有很大延迟的从机。（当用户刷新网页时这个场景很可能发生，每一个请求都发送到了一个随机服务器。）第一个查询请求返回了用户1234最近添加的一条评论，但是第二天查询请求并没有返回任何东西，因为延迟的从机还没有收到那条写入变更。实际上，相比于第一条查询请求第二条查询请求在一个更早的时间点观察系统。如果第一条查询请求没有返回任何东西这看起来不算太差，因为用户2345大概不知道用户1234最近添加了一条评论。然而，如果先看了用户1234的评论，之后又消失了，这会非常让用户2345困惑。

*图 5-4. 用户首先从更新了的副本读取，之后从旧的副本读取。时间看起来倒流了。我们需要单调读取来防止这种异常现象。*

*单调读取*保证了这一类异常情况不会发生。相比于强一致性它是一种弱保证，但是相比于最终一致性这是一种强保证。当读取数据时，你也许会看到一个旧的值；单调读取只意味着如果用户顺序发起了几个请求，他们不会看到时间倒流——也就是说，他们不会在之前读到新数据的情况下再读到旧数据。

实现单调读取的一种方式是保证每个用户都从同一个副本读取（不同的用户可以从不同的副本读取）。举个例子，副本的选择可以基于用户ID的哈希，而不是随机的。然而，如果那台副本故障了，用户的查询请求需要被重新路由到另外一台副本。

### 一致性前缀读取

复制延迟异常现象的第三个例子是关于因果关系违反的。设想下面一段Poons先生与Cake太太的对话

*Poons先生*

Cake太太，对于未来你能看多远？

*Cake太太*

通常大约十秒钟吧，Poons先生。

两句话之间有因果关系：Cake太太听到了Poons先生的问题并做出了回答。

现在，假设第三个通过从机再听这段对话。Cake太太说的话经过了一个有少许延迟的从机，但是Poons先生说的话有一个更长的复制延迟（见图5-5）。观察者会听到下面的对话：

*Cake太太*

通常大约十秒钟吧，Poons先生。

*Poons先生*

Cake太太，对于未来你能看多远？

对于观察者来说这看起来好像Cake太太正在回答Poons先生还没有问出口的问题。这种精神力量给人留下深刻印象，但是也会很困惑。

*图5-5 如果部分分库比其它的复制的慢，观察者会先看到答案再看到问题。*

避免这一类异常现象需要另一种类型的保证：一致性前缀读取。这种保证是说如果一系列写入以某种顺序发生，那么任何读取这些写入的人也会以同样的顺序看到这些写入。

这对于已分区的（已分片的）数据库来说是一个很特别的问题，我们会在第六章讨论它。如果数据库一致以同样的顺序应用写入动作，写动作会一直看到一致性前缀，于是这种异常不会发生。然而，在许多分布式数据库中，不同的分区独立地运行，所以没有写入地全局顺序的：当用户读取数据库时，他们会看到某些部分是旧的状态，而有一些已经是新的状态了。

一种解决方案是保证任何有因果关系的写入都去到了同一个分区——但是在一些应用中没有办法高效地完成。也有算法可以明确地保留因果关系记录，我们将在““之前发生”关系与并发”一节回到这个问题上。

### 复制延迟的解决方案

在使用最终一致系统时，很值得考虑一下当复制延迟上升到几分钟甚至几个小时的时候应用的行为如何。如果你的答案是“没问题”，这很好。然而，如果结果是用户体验很糟糕的话，为系统设计更强的保证，比如写入后的读取，是很重要的。假装复制是同步的但实际上是异步的注定会导致问题。

如前面所讨论的，应用程序相比于底层数据库提供更强的保证是有许多种方式的——举个例子，在领机上执行特定类型的读取。然而在应用程序代码中处理这些问题会很复杂并且很容易出错。

如果应用程序开发者不用考虑细微的复制问题而是相信数据库就可以“做正确的事”，那就更好了。这就是事务存在的原因：这是一种数据库提供更强保证的方式，于是应用变得更简单。

单节点事务已经存在很长时间，然而，在转向分布式（复制了的或者分区了的）数据库时，许多系统放弃了它，声称事务对于性能以及可用性来说都代价太高了，并且断言最终一致性在可扩展系统中是无法避免的。这段表述部分是事实，但是过于简单了，而我们会在本书的余下部分构建更细致入微的观点。我们会在第七、九章回到事务这个主题，而在第三部分讨论一些替代机制。

## 多领机复制

本章截至到目前我们只考虑了使用单个领机的复制架构。虽然那是一种常见的方式，但是也有许多有趣的替代方案。

基于领机的复制有一个重大的缺点：只有一个领机，所有的写入请求都必须通过它完成。如果你因为任何原因无法连接到领机，比如说因为你与领机之间的网络故障，你无法写入到数据库中。

基于领机复制模型的一种自然扩展是允许一个以上的节点接受写入请求。复制过程与先前方式一模一样：每一个处理写入请求的节点都比如转发数据变更到所有其它的节点。我们把这个叫做多领机配置（也叫做主-主或者主动/主动复制）。在这种配置下，每一个领机同时也是其它领机的从机。

### 多领机复制的用例

在单个数据中心内配置多领机几乎没有意义，因为带来的好处抵不过增加了的复杂度。然而，在某些情况下这种配置是合理的。

#### 多数据中心运营

设想你有一个数据库，副本分布在几个不同的数据中心内（也许这样你可以容忍整个数据中心故障，或是为了使它们更靠近用户）。对于普通的基于领机的复制配置来说，领机必须位于其中一个数据中心内，而所有的写入请求都必须通过那个数据中心。

在一个多领机配置中，你可以在每一个数据中心都有一个领机。图5-6显示了这样的架构大概使什么样子的。在每个数据中心中，使用正常的领机-从机复制；在数据中心之间，每个数据中心的领机把自己的变更复制给其它数据中心的领机。

*图5-6 横跨多个数据中心的多领机复制*

让我们比较一下在多数据中心部署环境中单领机与多领机配置的情况：

*性能*

在单领机配置中，每一个写入请求都必须穿过互联网抵达领机所在的数据中心。这会明显增加写入的延迟，也可能与使用多个数据中心的首要目的相抵触。在多领机配置中，每个写入都可以在本地数据中心处理，然后异步复制到其它数据中心去。因而数据中心之间的网络延迟对用户是不可见的，这意味着感受到的性能也许会更好一些。

*数据中心离线忍耐度*

在单领机配置中，如果领机所在的数据中心故障了，故障迁移可以吧另一个数据中心的从机提升为主机。在多领机配置中，每一个数据中心可以独立运行，当故障了的数据中心重新上线时复制过程可以重新赶上来。

*网络问题忍耐度*

数据中心之间的交通通常穿越公共互联网，它相比于数据中心内的本地网络就不太可靠了。单领机的配置对于这个数据中心之间的链路问题非常敏感，因为写入请求是在这个链路上同步发出的。异步复制的多领机配置通常可以更好的忍耐网络问题：临时的网络中断不会妨碍处理写入请求。

一些数据库默认支持多领机配置，但是也经常利用外部工具实现，比如针对MySQL的Tungsten Replicator，针对PostgreSQL的BDR，以及针对Oracle的GoldenGate。

虽然多领机复制有优势，但是他也有一个大缺点：同样的数据也许同时在两个不同的数据中心内处理，这种写入冲突必须要解决（如图5-6中标识为“解决冲突”的）。我们会在“处理写入冲突”一节讨论这个问题。

由于多领机复制在许多数据库中是某种程度上有所改进的功能，经常会有一些细微的配置陷阱以及与其它数据库功能令人意外的交互。举个例子，自增长的键，触发器，以及完整性约束是很有问题的。由于这样的原因，多领机复制经常被认为是需要尽量避开的危险地带。
