# 第五章 副本

*一个可能出错的事物和一个不可能出错的事物之间的主要区别是，当一个不可能出错的事物出错时，通常没办法用也没办法修了。*

---

道格拉斯·亚当斯，*基本无害*（1992）

副本的意思是保存同一份数据的拷贝在数台通过网络连接的设备上。在第二部分的介绍中我们提到，想要复制数据有下面好几个原因：

* 让数据在物理位置上更靠近你的用户（因而降低了延迟）

* 即使在某些部分失效的情形下允许系统继续工作（因而增加了可用性）

* 增加了服务读取请求的设备数量（因而增加了读取吞吐量）

在这一章我们会假设你的数据集很小以至于单个设备就可以保存整个数据集的拷贝。在第六章我们会放开这个假设条件，讨论对单个设备太大的数据集的*分库*（*分片*）。在更后边的章节我们会讨论可以发生在复制的数据系统的各种不同种类的故障，以及如何处理它们。

如果复制的数据不会随时间变化，那么复制过程就很简单：你只需要把数据拷贝到各个节点，就这样。所有复制过程中的难题都发生在如何处理复制后数据的变化，这一章就是讲这些的。我们将讨论三种流行的节点间复制变更的算法：*单主机*，*多主机*，以及*无主机*复制。几乎所有的分布式数据库都使用这三种方式之一。它们都有各种优缺点，稍后我们会详细的研究。

副本有许多权衡需要考虑：觉个例子，用同步复制还是异步复制，如何处理失败的副本。它们通常是数据库中的可配置选项，尽管每个数据库细节都不一致，但是一般性的原则在众多不同的实现之间还是类似的。我们会在这一章讨论各种选择所带来的后果。

数据库副本是个旧话题——自1970年代被研究之后原则并没有太大的变化，因为网络的基础限制依然没变。然而在研究之外的地方，许多开发者很长一段时间继续假设数据库只包含一个节点。分布式数据库的主流应用是最近的事。由于许多应用开发者是该领域的新手，对类似*最终一致性*这样的问题一致有许多错误理解。在“TODO:副本延迟的问题”一节我们会更精确地了解最终一致性，并且讨论例如*读取你的写入*以及*单调读取保证*这样的问题。

## 领机与从机

每一个储存着数据库拷贝的节点叫做*副本*。有了多个副本，有个问题难免会有：我们如何保证数据拷贝到了所有的副本上？

每次对数据库的写入都需要被每一个副本处理；否则，副本不再包含着同一份数据了。最常见的解决方式叫做*基于领机的复制*（也叫做*主动/被动*或者*主从复制*），如图5-1所示。工作原理如下：

1. 副本之一被指定为领机（也叫做主机）。当客户端要写入数据库时，它们必须发送请求到领机，它首先把新数据写入到本地存储中。

2. 其它副本称为*从机*（*读取副本*，*从机*，*辅机*，或者*热待机*）。每当领机写入新数据到自己的本地存储，它也发送数据变更到它的所有从机，作为复制日志或者变更流的一部分。每个从机从领机获取日志并更新对应的本地数据库拷贝，它按照领机上处理的相同的顺序应用所有的写入操作。

3. 当客户端要读取数据库时，它既可以查询领机也可以查询任意从机。然而，写入只会被领机接受（从客户端的角度看，从机是只读的）。

*图5-1 基于领机的（主从）复制*

这种模式的复制是许多关系型数据库，比如PostgreSQL（自从9.0版本）、MySQL、Oracle Data Guard以及SQL Server的AlwaysOn Availability Groups的内建功能。它也被用在一些非关系型数据库中，包括了MongoDB、RethinkDB以及Espresso。最后，基于领机的复制并不只局限于数据库：分布式的消息代理例如Kafka以及RabbitMQ高可用队列也使用它。一些网络文件系统以及复制块设备比如（DRBD）也很类似。

### 同步复制 vs 异步复制

副本系统的一个重要细节是复制是*同步*发生的还是*异步*发生的。（在关系型数据库中，这通常是一个可配置选项；其它系统通常是硬编码为二者之一。）

考虑一下图5-1中发生了什么，其中的网站用户更新了他的资料图片。在某个时刻，客户端发送了更新请求到领机；稍后，请求被领机接受。再在某个时刻，领机把数据变更转发到从机。最终，领机通知客户端更新成功。

图5-2现实了系统众多组件之间的通信：用户的客户端，领机，以及两个从机。时间从左向右流逝。请求与响应消息是用粗箭头表示的。

*图5-2 基于领机的复制，其中一个同步从机一个异步从机*

在图5-2的势力中，复制到从机1是同步的：领机等待从机1直至从机1确认完成了写入动作之后才向用户报告成功，同时也才让写入对其他客户端可见。复制到从机2是异步的：领机发送消息，但是不会等待来自从机的响应。

图标显示了从机2处理消息之前有足够的延迟。通常，复制是相当快的：大多数数据库系统不到一秒钟就可以应用变更到从机。然而，并不能保证这个动作会花多长时间。有情况显示从机有可能落后于领机几分钟，甚至更多；举个例子，比如从机正在从故障中恢复，比如系统负载几乎为满，比如节点之间网络有问题。

同步复制的优势在于从机保证可以获得最新的、与领机一致的数据。如果领机突然崩溃，我们可以确定从机上的数据依然可用。缺点在于同步从机如果不响应（由于崩溃，或者网络故障，或者任何其他原因），写入将不能继续处理。领机必须阻塞所有的写入，直至同步副本再次可用。

因为这样的原因，那么所有的从机都是同步的就不现实了：任意节点离线都会导致整个系统陷于停顿。实践中，如果为数据库启用了同步复制，这通常意味着只有一个从机是同步的，而其他从机都是异步的。如果同步从机不可用或者变慢，可以把一个异步从机变为同步的。这保证了最新的数据至少出现在两个节点上：领机与一个同步从机。这种配置被叫做*半同步*。

很多时候，基于领机的复制是被配置成完全异步的。在这种情况下，如果领机故障也无法恢复的花，任何没有复制到从机的写入都会丢失。这意味着写入是无法保证的，哪怕客户端已经确认了。然而，完全异步配置也有优势，领机可以一致处理写入请求，哪怕所有的从机都落后于领机。

削弱耐久性听起来像是一个馊主意，但是异步复制仍然被广泛使用，尤其是有许多从机，或者从机分布在不同的地方。我们会在“复制延迟的问题”一节回到这个问题上。

> 关于复制的研究
>
> 对于异步复制系统来说领机崩溃导致的数据丢失是一个很严重的问题，于是研究者依然在探索不会导致数据丢失但仍然提供良好性能于可用性的复制方法。比如，*链式复制*是同步复制的一个变种，已经成功应用在了类似微软Azure Storage这样的部分系统中了。
>
> 复制的一致性与共识（让好几个节点同意某个值）之间有很强的联系，我们会在第九章更详细地探索这个领域的理论。在这一章我们会集中在哪些实践中数据库上最长用到的简单复制形式上。

### 设置新的从机

时不时，你需要设置新的从机——也许是为了增加副本的数量，或者是替换崩溃的节点。你如何保证新的从机有着与领机一模一样的数据？

只是把数据从一个节点拷贝到另一个节点通常是不够的：客户端在持续地写入数据库，数据一直在变化，那么标准的文件拷贝在不同的时间点会看到数据库的不同部门。这样的结果没有任何意义。

你可以通过锁住数据库（从而无法写入）使磁盘上的文件一致，但是这违背了我们追求高可用性的目标。幸运的是，设置从机通常不会产生离线时间。定义上的流程是这样的：

1. 获取某个时间点的领机数据库的一致性快照——如果可能的话，不锁整个数据库。大多数数据库有这个功能，因为备份也是需要它的。在某些情况下，还需要第三方工具，例如MySQL的*innobakcupex*。

2. 把快照拷贝到新从机节点。

3. 从机连接到主机并请求所有发生在快照截取之后的数据变更。这要求快照绑定到了领机复制日志中的一个精确位置。这个位置有许多个名字：举个例子，PostgreSQL把它叫做*日志序列号*，而MySQL把它叫做*二进制日志坐标*

4. 当从机处理了自快照起积压的数据变更后，我们说它*赶上来*了。这是可以继续并开始处理来自领机的刚刚发生的数据变更。

设置从机的实际步骤由于数据库而非常不同。在某些系统中这个过程是全自动的，而在其它的里边它可以是某种神秘的多步骤工作流，需要管理员手动执行。

## 处理节点离线

系统中的任意节点都可以下线，也是是因为意外的故障，或者只是因为到了事先计划好的维护时间（举个例子，重启设备以安装内核安全补丁）。可以重启独立节点而不造成停机对于运维来说是巨大的优势。因此，我们的目标是保持系统作为一个整体运行良好而不在意个别节点崩溃，以为保持节点离线的影响越小越好。

对于基于领机的复制如何实现高可用性呢？

### 从机故障：追赶恢复

每一台从机在自己的本地磁盘上都保存了来自领机的数据变更的日志。如果从机崩溃然后重启，或者领机与从机之间的网络临时受阻，从机可以相当轻松的恢复：它从自己的日志知道故障发生钱最后一个被处理的事务。因而，从机可以连接到领机并请求自断线以后发生的所有数据变更。当这些变更应用完毕时，从机追赶上了领机并可以如往常一样接受数据变更流。

### 领机故障：故障迁移

处理领机故障更复杂一些：一台从机需要升级为新的领机，客户端需要重新配置才能发送写入请求到新的领机，同时其他从机需要开始处理来自新领机的数据变更。这个过程叫做*故障迁移*。

故障迁移可以手动触发（管理员接到领机故障的通知，采取必要措施构建新的领机）或者完全自动化。自动化故障迁移流程通常包含下面几步：

1. *判断领机故障*。许多事都有可能出错：系统崩溃，停电，网络问题，等等。没有简单明了的方式判断到底哪除了问题，所以绝大部分系统只是用了超时：节点频繁地在彼此之间来回传递消息，如果节点在一段时间内没有响应——比如说，30秒——我们就假设它崩溃了。（如果领机由于计划好的维护而估计下线的，就不适用了。）

2. *选择一个新领机*。这可以通过一个选举过程（领机由余下副本的大多数投票选择）解决，或者由先前指定的*控制器节点*指定新领机。最佳的备选通常是有着来自旧领机最新数据变更（把数据丢失风险降到最低）的副本。使所有节点都同意新领机是一个共识问题，会在第九章具体讨论。

3. *重新配置系统，使用新领机*。客户端现在需要发送它们的写入请求到新领机（会在“路由请求”一节讨论）。如果旧的领机恢复，它有可能还认为自己是领机，没有意识到其它副本强制它卸任了。系统需要保证旧领机变为从机，并且识别出新的领机。

故障迁移也注定有许多可能出错的事情：

* 如果使用了异步复制，新的领机可能在旧领机故障之前并没有接收到所有的写入。如果旧领机在新领机被选举出来之后重新加入到簇，这些写入怎么办呢？同时新领机也有可能收到冲突的写入。最常见的解决方案是旧领机丢弃没有被复制的写入，但是这样也许违背了客户端在持久性方面的预期。

* 如果数据库之外其它的存储系统需要与数据库内容协调的花，丢弃写入是极其危险的。举个例子，在GitHub的一次时间中，一个许久没有更新的从机被提升为领机。数据库使用了一个自增长的计数器给新插入的行分配主键，但是因为新领机的计数落后于旧领机的，于是重用了一些已经被旧领机分配过了的主键。这些主键也被用在了一个Redis存储中，主键的重用导致了MySQL与Redis之间不再保持一致，引发了某些私人数据暴露给了错误的用户。

* 在特定的故障场景（见第八章），两个节点都认为自己是领机的情况是会发生的。这种情况被叫做*脑裂*，这很危险：如果两个领机都接受写入请求，没有流程来处理冲突（见“多领机复制”一节），数据很有可能被丢失或者损坏。某些系统有机制在检测到两个领机后关闭其中一个节点。然而如果这个机制设计不是很细心的话，有可能最终两个节点都会被关闭。

在领机被宣布故障之前正确的超时是多少呢？超时时间更长意味着领机故障需要更长的时间恢复。然而如果超时过短，也可能发生不必要的故障迁移。举个例子，短时间负载高峰也许会让节点的响应时间超时，网络小故障也会导致包延迟。如果系统已经在高负载或是网络问题中苦苦挣扎，不必要的故障迁移极有可能使情况变得更糟，而不是更好。

这些问题都没有简单的解决方案。由于这个原因，某些运营团队更倾向于手动执行故障迁移，哪怕软件本身支持自动故障迁移。

这些问题——节点故障；不可靠的网络；以及副本一致性，持久性，可用性之间的权衡，以及延迟——实际上是分布式系统的基本问题。在第八和第九章我们会深度讨论它们。

### 复制日志的实现

基于领机的复制到底是如何工作的？实践中使用几种不同的复制方法，让我们简要了解一下每一种方法。

#### 基于语句的复制

在最简单的情况，领机记录每一个它执行地写入请求（语句），然后发送语句日志到它地从机。对于关系型数据库，这意味着每一个`INSERT`、`UPDATE`或`DELETE`语句都转发给了从机，每个从机解析并执行这个SQL语句如果它是直接来自客户端的。

虽然这听起来很合理，但是这种方式有许多种失败的可能：

* 任何语句调用非确定性函数，比如`NOW()`以获取当前日期与时间或者`RAND()`以获取随机数，在不同副本很有可能生成不同的值。

* 如果语句用到自增的列，或者是依赖数据库中已有的数据（比如，`UPDATE ... WHERE <some condition>`），他们在每一个副本上必须以完全一致的顺序执行，否则它们也许有不同的结果。当有多个并发执行的事务时，这会是很大的限制。

* 有副作用的语句（比如触发器，存储过程，用户定义函数）会在每一个副本上触发不同的副作用，除非副作用是绝对确定性的。

绕过这些问题是可能的——举个例子，领机可以在记录语句时用固定的返回值替换任何非确定性函数调用，从而所有从机都获得相同的值。然而，因为有许多边缘情况，其它复制方法现在通常更受欢迎。

MySQL在5.1版本之前使用基于语句的复制。今天依然有时在用，由于相当紧凑，但是如果语句中有任何不确定性默认的MySQL会切换到基于行的复制（稍后将讨论到）。VoltDB使用基于语句的复制，通过要求事务是确定性的使之安全。
