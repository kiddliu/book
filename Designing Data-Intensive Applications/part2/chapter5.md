# 第五章 副本

*一个可能出错的事物和一个不可能出错的事物之间的主要区别是，当一个不可能出错的事物出错时，通常没办法用也没办法修了。*

---

道格拉斯·亚当斯，*基本无害*（1992）

副本的意思是保存同一份数据的拷贝在数台通过网络连接的设备上。在第二部分的介绍中我们提到，想要复制数据有下面好几个原因：

* 让数据在物理位置上更靠近你的用户（因而降低了延迟）

* 即使在某些部分失效的情形下允许系统继续工作（因而增加了可用性）

* 增加了服务读取请求的设备数量（因而增加了读取吞吐量）

在这一章我们会假设你的数据集很小以至于单个设备就可以保存整个数据集的拷贝。在第六章我们会放开这个假设条件，讨论对单个设备太大的数据集的*分库*（*分片*）。在更后边的章节我们会讨论可以发生在复制的数据系统的各种不同种类的故障，以及如何处理它们。

如果复制的数据不会随时间变化，那么复制过程就很简单：你只需要把数据拷贝到各个节点，就这样。所有复制过程中的难题都发生在如何处理复制后数据的变化，这一章就是讲这些的。我们将讨论三种流行的节点间复制变更的算法：*单主机*，*多主机*，以及*无主机*复制。几乎所有的分布式数据库都使用这三种方式之一。它们都有各种优缺点，稍后我们会详细的研究。

副本有许多权衡需要考虑：觉个例子，用同步复制还是异步复制，如何处理失败的副本。它们通常是数据库中的可配置选项，尽管每个数据库细节都不一致，但是一般性的原则在众多不同的实现之间还是类似的。我们会在这一章讨论各种选择所带来的后果。

数据库副本是个旧话题——自1970年代被研究之后原则并没有太大的变化，因为网络的基础限制依然没变。然而在研究之外的地方，许多开发者很长一段时间继续假设数据库只包含一个节点。分布式数据库的主流应用是最近的事。由于许多应用开发者是该领域的新手，对类似*最终一致性*这样的问题一致有许多错误理解。在“TODO:副本延迟的问题”一节我们会更精确地了解最终一致性，并且讨论例如*读取你的写入*以及*单调读取保证*这样的问题。

## 领机与从机

每一个储存着数据库拷贝的节点叫做*副本*。有了多个副本，有个问题难免会有：我们如何保证数据拷贝到了所有的副本上？

每次对数据库的写入都需要被每一个副本处理；否则，副本不再包含着同一份数据了。最常见的解决方式叫做*基于领机的复制*（也叫做*主动/被动*或者*主从复制*），如图5-1所示。工作原理如下：

1. 副本之一被指定为领机（也叫做主机）。当客户端要写入数据库时，它们必须发送请求到领机，它首先把新数据写入到本地存储中。

2. 其它副本称为*从机*（*读取副本*，*从机*，*辅机*，或者*热待机*）。每当领机写入新数据到自己的本地存储，它也发送数据变更到它的所有从机，作为复制日志或者变更流的一部分。每个从机从领机获取日志并更新对应的本地数据库拷贝，它按照领机上处理的相同的顺序应用所有的写入操作。

3. 当客户端要读取数据库时，它既可以查询领机也可以查询任意从机。然而，写入只会被领机接受（从客户端的角度看，从机是只读的）。

*图5-1 基于领机的（主从）复制*

这种模式的复制是许多关系型数据库，比如PostgreSQL（自从9.0版本）、MySQL、Oracle Data Guard以及SQL Server的AlwaysOn Availability Groups的内建功能。它也被用在一些非关系型数据库中，包括了MongoDB、RethinkDB以及Espresso。最后，基于领机的复制并不只局限于数据库：分布式的消息代理例如Kafka以及RabbitMQ高可用队列也使用它。一些网络文件系统以及复制块设备比如（DRBD）也很类似。

### 同步复制 vs 异步复制

副本系统的一个重要细节是复制是*同步*发生的还是*异步*发生的。（在关系型数据库中，这通常是一个可配置选项；其它系统通常是硬编码为二者之一。）

考虑一下图5-1中发生了什么，其中的网站用户更新了他的资料图片。在某个时刻，客户端发送了更新请求到领机；稍后，请求被领机接受。再在某个时刻，领机把数据变更转发到从机。最终，领机通知客户端更新成功。

图5-2现实了系统众多组件之间的通信：用户的客户端，领机，以及两个从机。时间从左向右流逝。请求与响应消息是用粗箭头表示的。

*图5-2 基于领机的复制，其中一个同步从机一个异步从机*

在图5-2的势力中，复制到从机1是同步的：领机等待从机1直至从机1确认完成了写入动作之后才向用户报告成功，同时也才让写入对其他客户端可见。复制到从机2是异步的：领机发送消息，但是不会等待来自从机的响应。

图标显示了从机2处理消息之前有足够的延迟。通常，复制是相当快的：大多数数据库系统不到一秒钟就可以应用变更到从机。然而，并不能保证这个动作会花多长时间。有情况显示从机有可能落后于领机几分钟，甚至更多；举个例子，比如从机正在从故障中恢复，比如系统负载几乎为满，比如节点之间网络有问题。

同步复制的优势在于从机保证可以获得最新的、与领机一致的数据。如果领机突然崩溃，我们可以确定从机上的数据依然可用。缺点在于同步从机如果不响应（由于崩溃，或者网络故障，或者任何其他原因），写入将不能继续处理。领机必须阻塞所有的写入，直至同步副本再次可用。

因为这样的原因，那么所有的从机都是同步的就不现实了：任意节点离线都会导致整个系统陷于停顿。实践中，如果为数据库启用了同步复制，这通常意味着只有一个从机是同步的，而其他从机都是异步的。如果同步从机不可用或者变慢，可以把一个异步从机变为同步的。这保证了最新的数据至少出现在两个节点上：领机与一个同步从机。这种配置被叫做*半同步*。

很多时候，基于领机的复制是被配置成完全异步的。在这种情况下，如果领机故障也无法恢复的花，任何没有复制到从机的写入都会丢失。这意味着写入是无法保证的，哪怕客户端已经确认了。然而，完全异步配置也有优势，领机可以一致处理写入请求，哪怕所有的从机都落后于领机。

削弱耐久性听起来像是一个馊主意，但是异步复制仍然被广泛使用，尤其是有许多从机，或者从机分布在不同的地方。我们会在“复制延迟的问题”一节回到这个问题上。

> 关于复制的研究
>
> 对于异步复制系统来说领机崩溃导致的数据丢失是一个很严重的问题，于是研究者依然在探索不会导致数据丢失但仍然提供良好性能于可用性的复制方法。比如，*链式复制*是同步复制的一个变种，已经成功应用在了类似微软Azure Storage这样的部分系统中了。
>
> 复制的一致性与共识（让好几个节点同意某个值）之间有很强的联系，我们会在第九章更详细地探索这个领域的理论。在这一章我们会集中在哪些实践中数据库上最长用到的简单复制形式上。

### 设置新的从机

时不时，你需要设置新的从机——也许是为了增加副本的数量，或者是替换崩溃的节点。你如何保证新的从机有着与领机一模一样的数据？

只是把数据从一个节点拷贝到另一个节点通常是不够的：客户端在持续地写入数据库，数据一直在变化，那么标准的文件拷贝在不同的时间点会看到数据库的不同部门。这样的结果没有任何意义。

你可以通过锁住数据库（从而无法写入）使磁盘上的文件一致，但是这违背了我们追求高可用性的目标。幸运的是，设置从机通常不会产生离线时间。定义上的流程是这样的：

1. 获取某个时间点的领机数据库的一致性快照——如果可能的话，不锁整个数据库。大多数数据库有这个功能，因为备份也是需要它的。在某些情况下，还需要第三方工具，例如MySQL的*innobakcupex*。

2. 把快照拷贝到新从机节点。

3. 从机连接到主机并请求所有发生在快照截取之后的数据变更。这要求快照绑定到了领机复制日志中的一个精确位置。这个位置有许多个名字：举个例子，PostgreSQL把它叫做*日志序列号*，而MySQL把它叫做*二进制日志坐标*

4. 当从机处理了自快照起积压的数据变更后，我们说它*赶上来*了。这是可以继续并开始处理来自领机的刚刚发生的数据变更。

设置从机的实际步骤由于数据库而非常不同。在某些系统中这个过程是全自动的，而在其它的里边它可以是某种神秘的多步骤工作流，需要管理员手动执行。