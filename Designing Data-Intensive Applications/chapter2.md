# 第二章 数据模型与查询语言

*我的语言的界限就是我的世界的界限。*

路德维希·维特根斯坦，逻辑哲学论

数据模型也许是软件开发中最重要的部分了，因为它们有着最深刻的作用：不仅仅是关于软件要怎么写，更是关于我们如何思考我们要解决的问题。

大部分应用程序是通过数据模型层叠构建起来的。对于每一层来说核心问题是：它是如何用下一层术语*表现*的？举个例子：
1. 作为一个应用程序开发者，你看着真实世界（在其中有人、组织、物品、动作、资金流动、传感器等等）然后用对象或者数据结构对它建模，并构建操作这些数据结构的API。这些数据结构通常是特定于你的应用的。
2. 当你要存储这些数据结构，你用一种通用数据结构表达它们，比如JSON文档或者XML文档，关系型数据库中的表，亦或是一个图模型。
3. 构建你使用的数据库软件的工程师先前决定了JSON/XML/关系型/图型数据是如何用内存、硬盘或是网络上的字节流表现方式。
4. 在更低的层，硬件工程师已经想通了如何用电流、光脉冲、磁场来表现字节。

在一个复杂的应用中也许会存在更多的中间层，比如API构建在其它API之上，但是基本的想法仍然是一致的：每一层通过提供一个干净的数据模型隐藏其下层次的复杂性。这样的抽象允许不同的人群——比如，数据库供应商的工程师与使用数据库的应用程序工程师——有效地协作。

市面上有许多种不同的数据模型，且每一种数据模型都包含了如何使用它的假设。有一些用法很简单而有一些是不支持的；有一些操作是很快的而有一些执行起来很差；有一些数据转换很自然而有一些很别扭。

哪怕只是掌握一种数据模型也是会花费很大精力的（想想市面上有多少本关系型数据建模的书就可想而知了）。构建软件已经很困难了，哪怕只是使用一种数据模型并且不计较它的内部实现。但是由于数据模型对构建于其上的软件有着至深的影响，选择一个适合这个应用的就很重要了。

在这一章中我们将研究一系列针对数据存储与查询的通用数据结构（对应先前列表中的第2点）。特别的是我们将比较关系型、文档型以及一小部分基于图的数据结构。我们也将研究众多的查询语言并计较它们的使用场景。在第三章中我们将讨论存储引擎是如何工作的；也就是，这些数据模型实际中是如何实现的（对应先前列表中的第3点）。

## 关系型模型 vs 文档型模型

今天最为人所知的数据模型大概就是SQL了，基于1970年Edgar Codd建议的关系型模型：数据被组织为*关系*（在SQL中称为*表*），其中每一种关系都是一个*元组*的无序集合（在SQL中成为*行*）。

关系型模型是一个理论性建议，当时的许多人怀疑它能否有效率地实现出来。然而到了80年代中期，关系型数据库管理系统（RDBMSes）和SQL成为了大多数需要存储和查询某种规则结构的选择。关系型数据库称霸行业持续了25到30年——对于计算机历史来说这么长的时间就是永恒。

关系型数据库根源在于*业务数据处理*，在六七十年代主流计算机都在执行它。从今天的角度看这样的使用场景很平凡：一般是*交易处理*（输入销售数据或者银行交易、航班预订、货仓物管）和*批量处理*（客户发票、账单、报告）。

当时其它数据库强迫应用程序开发者考虑很多数据在数据库中的内部格式。关系型模型的目标则是隐藏这些实现细节，取而代之的是更加干净的接口。

这么多年以来，出现了许多与之竞争的数据存储与查询方式。七十年代到八十年代初，*网络模型*和*分层模型*是主要的备选方案，但是最终关系型模型还是主宰了市场。对象数据库在八十年代末九十年代初昙花一现。新世纪初又出现了XML数据库，但是只有少量的采用。关系型模型的竞争对手们在出现时都引起了不少炒作，但都没有持续很长时间。

随着计算机变得越来越强大并互相联网，使用场景也开始变得更加分散。值得骄傲的是，关系型数据库结果通用化做得非常好，它超越了最初只是进行业务数据处理的范围而扩展到了更广的使用场景中。许多现如今你看到的网络依旧是关系型数据库支撑的，比如在线出版、讨论、社交网络、电子商务、游戏、即需即用的效率型应用等等。

### NoSQL的诞生

如今，NoSQL是推翻关系型模型绝对统治力的最新一次尝试。这个名字相当不幸，因为实际上它并不指代任何特定的技术——最初只是在Twitter上为2009年的一次开源分布式非关系型数据库会议设计的主题标签，它很好记。然而，这个名字像发了疯一样迅速火遍了网络初创社区。今天一些有趣的数据库系统都打上了#NoSQL标签，而且重新解释成*不只是SQL*。

引入NoSQL数据库背后的驱动力有这么几个，包括：
* 需要一种比关系型数据库更容易达成的高扩展度，包括非常大的数据集或者非常高的写入吞吐量
* 相比于商业数据库软件，普遍偏向选择免费开源软件
* 关系型模型对特殊定制化的查询操作支持不佳
* 受限于关系型模式定义的严格，需要一种更动态和更有表达性的数据模型


### 对象-关系不匹配

今天大部分应用开发使用面向对象编程语言完成的，对SQL数据模型的批评由此引出：如果数据存储在关系型表里，那必然存在一个在程序代码与数据库模型（表、行、列）之间的尴尬转换层。这种模型之间无法衔接也被戏称为*阻抗不匹配*。

类似ActiveRecord和Hibernate这种对象关系映射框架减少了这一层必不可少的样板代码量，然而它们不可能完全的掩盖两种模型之间的差别。

举例来说，图2-1展示了一份简历（一份LinkedIn资料）是如何用关系型模式定义表达的。这份资料作为一个整体可以用一个唯一标识符标识，`user_id`。诸如`first_name`和`last_name`这样的字段每个用户只出现一次，所以它们可以被建模为`users`表中的列。然而，大多数人在他们的职业生涯中都做过超过一份工作（或职位），人们的受教育经历也不同数量的几段时间，联系方式也是类似。用户与这些项之间是一对多的关系，可以用很多种方式表达：
* 在传统SQL模型（SQL:1999之前），最常见的标准化格式是把职位、教育和联系方式存到不同的表里，用外键指向`users`表，如图2-1所示。
* 后续的SQL标准调价了对结构化数据类型和XML数据的支持；这允许多值数据可以存储在单行内，同时对这些文档支持查询和建立索引。Oracle、IBM DB2、MS SQL Server以及PostgreSQL对这些功能有着不同程度的支持。JSON数据类型也被少数几个数据库支持，包括IBM DB2、MySQL和PostgreSQL。
* 第三个选项是把工作、教育以及联系人信息编码为一个JSON或者XML文档，存在数据库的一个文本列内，让应用程序自己解析这个结构和内容。在这样的设置中，一般无法让数据库在编码后的列内进行查询。

对于类似简历这样的数据结构，大部分时候是一个独立的*文件*，用JSON表达是非常合适的：如示例2-1.相比于XML，JSON因为更简单于是更吸引人。类似MongoDB、RethinkDB、CouchDB以及Espresso这类面向文档的数据库支持这种数据类型。

*示例2-1 用JSON文档呈现一个LinkedIn资料*
```JSON
{
  "user_id":      251,
  "first_name":   "Bill",
  "last_name":    "Gates",
  "summary":      "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id":    "us:91",
  "industry_id":  131,
  "photo_url":    "/p/7/000/253/05b/308dd6e.jpg",
  "positions":    [
    {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
  ],
  "education":    [
    {"school_name": "Harvard University", "start": 1973, "end": 1975},
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ],
  "contact_info": {
    "blog":     "http://thegatesnotes.com",
    "twitter":  "http://twitter.com/BillGates"
  }
}
```
一些开发者感觉JSON模型降低了应用代码与存储层之间的阻抗不匹配。然而，在第四章我们将看到，用JSON作为数据编码格式也是有问题的。模式定义的缺失经常被认为是一种优势；我们会在“文档模型中模式定义的灵活性”讨论它。

在图2-1中JSON格式相比于多表模式有着更好的*本地性*。如果尝试从一个关系型示例中获取一份资料，你要么执行多次查询（通过`user_id`查询每一张表），要么在`users`与相关表上执行一次复杂的连接。相比之下在JSON格式中，所有相关的信息都在一起，一次查询就足够了。

用户资料与用户的职位、受教育经历以及联系方式之间构成了数据间的树状结构，JSON格式把这种结构呈现了出来（见图2-2）。

### 多对一与多对多关系

在前一节的示例2-1中，`region_id`与`industry_id`被定义为ID，而不是纯文本字符串如“大西雅图地区”和“慈善事业”。为什么？

如果用户界面提供了文本框以接收用户输入的地区与行业，把他们存储为纯文本字符串也算合理。但是准备好二者的标准化列表，并允许用户从下拉菜单选择或者自动补全也有它的好处：
* 所有资料有着一致的风格与拼写
* 避免混淆（比如有许多城市有着一样的名字）
* 更新方便——名字都存储在一个地方，一旦出现变化（比如由于政治事件城市名字变了）很容易进行全面更新
* 本地化的支持——当望着被翻译成另外一种语言，这些标准化的列表也可以被翻译，从而地区与行业可以使用用户的语言显示
* 更好的搜索——比如，由于地区列表包含了西雅图位于华盛顿州这样的事实（如果是字符串“大西雅图地区”就没有这么明显了），于是搜索华盛顿州的慈善家可以定位到这份资料

是存成一个ID还是一个字符串这是一个关于重复的问题。当你使用ID，那些对人们有意义的信息（比如*慈善家*这个词）只储存在一个位置，所有指向这个信息的地方都用ID代替（这只在数据库中是有意义的）。当你直接存储字符串的时候，所有使用它的地方都在重复着这些信息。

使用ID的优势在于它对于人是没有意义的，它本身不需要改变：哪怕它指向的信息变了，ID是可以保持不变的。而任何对于人有意义的事物将来都有可能会变——一旦这些信息被复制了，所有多余的拷贝都需要跟着更新。这导致了写入的开销，以及信息不一致的风险（有些拷贝更新了而有些没有）。移除这样的重复信息是数据库规范化的核心理念。

> #### 注意
数据库管理员与开发者之间喜欢争论规范化与去规范化，但是我们将暂时暂停这种争论。在本书的第三部分我们将会回到这个话题上来，研究应对缓存、去规范化以及衍生数据的系统化方式。

然而不幸的是，规划化这样的数据需要*多对一*关系（例如许多人住在同一个特定地区，许多人在同一个特定行业工作），放在文档模型中不是很合适。在关系型数据库中，通过ID指向其它表中的行是很平常的，因为连接很简单。在文档型数据库中，一对多的树状结构并不必要连接，因此连接的支持通常很差。

如果数据库本身不支持连接，你就必须在应用程序代码中通过多次查询数据库模拟它。（在这种情况下，地区与行业列表大概会很小，变化也很慢从而应用可以把他们存在内存中。但是不管怎样，进行连接的工作从数据库转到了应用程序代码。）

此外，哪怕应用的最初版本适配了没有连接支持的文档模型，数据总会由于功能的不断添加变得互相联系起来。举个例子，考虑一下我们可以对简历这个例子做某些变化：

*作为实体的组织与学校*

在之前的描述中，`organization`（用户曾经工作过的公司）与`school_name`（他们学习的地方）只是字符串。也许它们应该指向某些实体？那么每一个组织、学校或者大学可以有各自的网页（包括徽标、新闻摘要等）；每一份简历都可以链接到提及的组织与学校，包括他们的徽标以及其它信息（详见图2-3中来自LinkedIn的一个例子）。

*推荐信*

假如你想添加一个新功能：用户可以写推荐信给另外一个用户。推荐信会被显示在被推荐人的简历上，外加推荐人的姓名和照片。如果推荐人更新了自己的照片，他们写过的推荐信都需要更新。因而，推荐信应该有一个指向作者资料的链接。

图2-4展示了新需求需要的多对多关系。点线框内的数据可以被划为一组构成一个文档，但是指向组织、学校以及其它用户的链接将被定义为引用，查询时需要用到连接。

### 文档型数据库会重蹈覆辙么？

虽然多对对关系与连接在关系型数据库中每天都会用到，文档型数据库与NoSQL重新开启了在数据库中如何呈现这种关系才是最好的的争论。这个争论的历史比NoSQL的出现还要早——事实上，它可以追溯到最早的计算机数据库系统。

七十年代业务数据处理最流行的数据库是IBM的*Information Management System*（IMS），最初开发是为了阿波罗太空计划的仓储需要，首次商业发布是在1968年。它至今都还在使用和维护，运行在搭载OS/390的IBM大型机上。

IMS的设计使用了*分层模型*这种相当简单的数据模型，与文档型数据库使用的JSON模型有着某些显著的相似之处。所有的数据都表现为条目树并嵌套在一起，类似图2-2中的JSON结构。

就像文档型数据库一样，IMS很好地处理了一对多关系，但是也使多对多关系的实现很困难，并且不支持连接。开发者需要决定要么复制（去规范化）数据要么手动解析条目之间的引用。这些六七十年代的问题与今天开发者运行文档型数据库遇到的是非常类似的。

许多不同的方案尝试解决分层模型的这种局限性。两种最棒的方案分别是*关系型模型*（后来变成了SQL并横扫了全球）和*网络型模型*（最初有一大堆拥趸但是最终还是消失了）。两个阵营之间的“大争论”持续了七十年代大部分时间。

既然两种模型尝试解决的问题今天依旧有关，这值得我们用今天的视角重新回顾一下这个争论。

#### 网络模型

网络模型由数据系统语言会议（CODASYL）委员会标准化，并由几家数据库供应商实现；所以也被称为CODASYL模型。

CODASYL模型是一般化的分层模型。在分层模型的树结构中，每一个条目只有一个父条目；而在网络模型，一个条目是允许有多个父条目的。举个例子，允许有一个存储“大西雅图地区”的条目，并且允许所有生活在这个地区的用户链接到它。这可以为多对一与多对多关系建立模型。

网络模型中条目之间的链接不是外键，它更像是编程语言中的指针（但是仍然存储在磁盘上）。访问一个条目的唯一方式就是从根结点沿着链接链中的某条路径。这种方式叫做*访问路径*。

在最简单的场景中，一个访问路径就好像在遍历一个链表：从表头开始，每一次查看一个条目直到你找到你要的那个。但是在多对多关系的世界中，几条不同的路径可以指向同一个条目，使用网络模型的程序员需要在脑子里记住这些不同的访问路径。

CODASYL模型中的一次查询是通过移动数据库中的游标，遍历条目链表然后沿着访问路径获取结果。如果一个条目多个父条目（比如多个从别的条目指来的指针），应用程序代码必须记录所有这样的关系。甚至CODASYL委员会成员也承认这就好像在一个N元数据空间遨游。

虽然手动选择访问路径可以最有效率得使用七十年代非常有限的硬件资源（比如磁带驱动器，执行查询是非常非常慢的），然而问题是这使得查询与更新数据库的代码变得非常复杂而且毫无灵活性。假如同时是分层和网络模型而你没有想要访问的数据的路径，这时就很困难了。你可以改变访问路径，但是这样你必须要过一遍手写的数据库查询代码然后重写以处理新的访问路径。对应用程序的数据模型进行改变是非常困难的。

#### 关系型模型

相比之下，关系型模型做得是把所有数据展开：一种关系（表）只是元组（行）集合，就这么简单。没有迷宫一般的嵌套结构，查看数据的时候没有复杂的访问路径。你可以读取表内任意或者全部的行，然后挑选那些符合任意条件的。你可以通过指定某些列作为键并匹配这些键来读取特定的行。你可以插入一个新行到任意表而不用担心与其它表之间的外键关系。

在关系型数据库，查询优化器自动决定查询的哪一部分以哪一种顺序执行，以及使用哪一个索引。这些选择实际上就是“访问路径”，但是最大的差别在于这是查询优化器自动决定的，而不是应用程序开发者，所以我们几乎不用去考虑它们。

如果你想用新的方式去查询数据，你只需要声明一个新的索引，而之后的查询将自动使用最合适的索引。你不需要改变查询语句就可以利用新的索引。（参见“数据的查询语言”。）关系型模型因此使添加新功能到应用变得非常简单。

关系型数据库的查询优化器非常复杂，耗费了许多年的研究与开发工作。但是一个重要观点是：你只需要构建一次查询优化器，之后所有使用数据库的应用都可以从中获益。如果你没有查询优化器，写一个为特定查询硬编码访问路径的优化器比写一个通用的优化器要简单得多——但是通用的优化器长期来看是更有利的。

#### 与文档型数据库的比较

文档型数据库在一个方面与分层模型是一样的：嵌套条目（一对多关系，比如图2-1中的`positions`、`education`和`contact_info`）是储存在它的父条目而不是在单独一张表里。

然而在表示多对一与多对多关系时，关系型与文档型数据库并没有本质不同：两种情景下，相关项通过唯一标识符引用，在关系型模型中叫做*外键*而在文档型模型中叫做*文档引用*。标识符在读取时通过连接或者后续查询解析。截至目前，文档型数据库没有走CODASYL的老路。

### 关系型 vs 文档型数据库的现状

在比较关系型数据库与文档型数据库时有许多差别需要考虑，包括它们的容错属性（见第五章）以及对并发的处理（见第七章）。在这一章，我们只注意数据模型的差别。

倾向文档型数据模型的主要论据包括模式定义的灵活性、数据位置带来的更好的性能，以及对于某些应用来说它与应用程序使用的数据模型更加接近。而关系型模型的强项则是更好的对连接，以及多对一和多对多关系的支持。

#### 哪种数据模型可以得到更简单的应用程序代码？

如果你的应用的数据有着类似文档一样的结构（比如一对多关系的树，并且通常整个树是一次加载完毕的），那么使用文档模型大概是个好主意。关系型中的*撕裂*技术——把类似文档的数据结构分成几张表（比如图2-1中的`positions`、`education`和`contact_info`）——则会导致笨重的模式定义以及冗余的应用程序代码。

文档模型也有限制：例如：你不能直接引用文档中被嵌套的项，取而代之的是“用户251职位列表的第二项”（就像分层模型中的访问路径一样）。然而只要文档不是深度的嵌套，这通常不是个问题。

文档数据库对连接的差劲支持到底是不是个问题，这取决于应用。比如，在一个分析应用中使用文档数据库来存储什么事件发生在什么时间也许完全用不到多对多关系。

然而如果你的程序确实用到了多对多关系，那文档型模型就变得没有吸引力。为了降低对连接的需求而去规范化是有可能的，但是应用程序代码需要做额外的工作保证去规范化数据保持一致。连接可以通过对数据库发起多次请求在应用代码中模拟，但是这也把复杂性转移到了应用程序中，而这通常也比数据库中的定制化代码执行地慢。在这样的情况下，使用文档模型带来的是更复杂的代码以及更恶劣的性能问题。

一般地很难讲哪一种数据模型可以得到更简单的应用程序代码；这取决于数据项之间已有的关系种类。对于高度互联的数据，文档模型就很别扭，关系型模型可以接收，而图模型（见“图状数据模型”）则是最自然的。

### 文档模型中的模式定义灵活性

大多数文档型数据库，以及关系型数据库的JSON支持，都不强制文档中的数据必须要有模式定义。关系型数据库在支持XML时通常附带模式验证，但这也是可选的。没有模式定义意味着任意键值都可以添加到一个文档中，并且在读取时客户端无法保证文档包含了什么样的字段。

文档型数据库有时也被称为*无模式定义的*，但这会产生误解，毕竟读取数据的代码通常假设某种结构——也就是说，一种隐式的模式定义，但是数据库不强制它。更准确的说法应该是*读取时模式*（数据结构是隐式的，并且只在数据被读取时才被解释），与之对应的是*写入时模式*（关系型数据库的传统方式，模式定义是显式的并且数据库保证写入的数据是符合定义的）。

读取时模式类似编程语言中动态（运行时）类型检查，而写入时模式类似静态（编译时）类型检查。就好像静态与动态类型检查各自的倡导者对它们相对的有点有着巨大的争论一样，数据库中是否强制模式定义也是一个有争议的话题，总的来说是没有对错之分的。

两种方式的区别在应用程序打算修改数据格式的时候才会特别凸显出来。举例来说，假设你现在用一个字段储存每一个用户的全名，之后你想要分开储存姓与名。在文档数据库中，你会立即在新的文档中写入新的字段而让应用代码来处理读取到旧文档的情况。比如：
```JavaScript
if (user && user.name && !user.first_name) {
  // Documents written before Dec 8, 2013 don't have first_name
  user.first_name = user.name.split(" ")[0];
}
```
另一方面，在一个“静态类型的”数据库模式定义中，你一般会执行几行*迁移*命令：
```SQL
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1);      -- PostgreSQL
UPDATE users SET first_name = substring_index(name, ' ', 1); -- MySQL
```
模式定义变更是出了名的慢，而且需要离线操作。但是也不完全是这样：大部分关系型数据库系统执行`ALTER TABLE`语句只需要几个毫秒。MySQL是个例外——执行`ALTER TABLE`时它拷贝了整张表，在修改一张大表的时这意味着几分钟甚至几个小时的离线时间——虽然有许多工具尝试绕过这个局限。

在一张大表上执行`UPDATE`语句大概在任何一个数据库上都会慢，毕竟每一行都需要重写。如果无法接受这样的结果，应用可以让`first_name`字段为默认值`NULL`而在读取的时候才写入真实值，就好像文档型数据库一样。

读取时模式在集合中的项并不都是一摸一样结构的时候非常有优势（也就是说数据是混杂的）——举例来说，因为
* 其中有许多不同类型的对象，把每一种对象都放在单独一张表里不太现实。
* 数据格式是外部系统决定的，而你没有决定权，格式也会随时改变。

在这样的情况下，模式定义带来的坏处远大于它的好处，而无模式定义的文档则是更自然的数据模型。但是如果预计所有条目都有着一样的结构，模式定义就是很有用的手段了。我们将在第四章进一步讨论模式定义以及它的演化。

### 查询时的数据本地性

文档一般以连续字符串的形式保存，编码为JSON、XML或者类似二进制的变体（例如MongoDB使用的BSON）。如果你的应用经常需要访问整个文档（例如，把它呈现在网页上），那么数据本地性在性能上是有优势的。如果数据分散在好几张表中，比如图2-1中那样，获取所有数据就需要好几次索引查询，这可能导致好几次磁盘寻址从而花费更多的时间。

本地性优势只适用于同时需要大部分文档数据的时候。数据库通常需要加载整个文档，即使你只需要访问很少的一部分，对于大型文档来说这是一种浪费。更新文档的时候，通常整篇文档需要被重写——只有不改变文档编码大小的改动才可以方便地就地执行。由于这样的缘故，一般地我们推荐文档应当保持足够小并且避免增加文档大小的写入。这样的性能限制极大地降低了文档型数据库有用的场景数量。

同时值得指出的是把相关数据分组以获取本地性不止适用于文档型模型。比如Google的Spanner数据库为关系型数据模型提供了同样的本地性属性，它允许模式定义声明表内的行是否应当交错（嵌套）在父表中。Oracle提供了一样的功能，叫做*多表索引集群表*。Bigtable数据模型（被使用于Cassandra和HBase）中的*列族*概念也有着管理本地性的类似目的。

我们将在第三章看到更多关于本地性的内容。

### 文档型与关系型数据库的合流

大多数关系型数据库系统（除了MySQL以外）都于新世纪第一个十年中期支持了XML。它包含了本地修改XML文档、建立索引以及在XML文档内查询的功能，这允许应用程序使用非常类似于使用文档数据库时使用的数据模型。

对JSON文档类似的支持开始于PostgreSQL版本9.3，MySQL版本5.7以及IBM DB2版本10.5。由于Web API中JSON的流行，其它关系型数据库很有可能跟上脚步添加对JSON的支持。

在文档型数据库这一边，RethinkDB支持类似关系型连接的查询语言，而某些MongoDB驱动自动解析数据库引用（效果等同于执行一次客户端连接，但毕竟需要额外的网络往返而且欠缺优化，相比于数据库内的连接它很可能更慢）。

这看起来关系型与文档型数据库开始变得越来越相似，这是一件好事：两个数据模型互相补充。如果一个数据库既可以处理类似文档一样的数据也可以执行关系型查询，应用程序可以组合这些功能从而满足自己的需要。

关系型与文档型模型混合是未来数据库发展的一个好的方向。

## 数据的查询语言

引入关系型模型的时候，它包含了一个查询数据的新方式：SQL是一种*声明式*的查询语言，而IMS与CODASYL使用*命令式*代码查询数据库。这是什么意思？

许多常用的编程语言是声明式的。举个例子，如果你有一个动物种族的列表，你大概会写这样的代码返回列表中的鲨鱼：
```JavaScript
function getSharks() {
  var sharks = [];
  for (var i = 0; i < animals.length; i++) {
    if (animals[i].family === 'Sharks') {
      sharks.push(animals[i]);
    }
  }
  return sharks;
}
```
在关系代数中，你应该写：
> sharks = σ<sub>family = "Sharks"</sub>(animals)

其中σ(希腊字母西格玛)是选择操作符，返回只符合条件`family = "Sharks"`的动物。

在定义SQL的时候，它遵循了关系代数的结构而且相当接近：
```SQL
SELECT * FROM animals WHERE family = 'Sharks';
```
命令式语言告诉计算机以某种顺序执行某些操作。你可以想象逐行扫描代码、评估条件、更新变量，然后决定是不是要再来一遍。

在声明式查询语言中，类似SQL或者关系代数，你只需要描述所需数据的模式——结果必须满足什么样的条件，以及你需要数据如何转化（比如，排序，分组以及聚合）——而不是*如何*达成这个目标。这是由数据库系统的查询优化器决定使用哪些索引哪些连接方法，以及以什么样的顺序执行查询的不同部分。

声明式查询语言是诱人的，因为相对于命令式API它通常更简洁且更易用。但更重要的是，它还隐藏了数据库引擎的实现细节，从而使数据库在不需要查询语句任何变更的情况下可以提升性能。

比如，在这一节开始展示的命令式代码，动物列表是以特定顺序出现的。如果数据库要在后台回收未使用的磁盘空间，它也许需要移动条目，表更动物出现的顺序。数据库可以安全地做到这些吗，在不破坏查询语句的情况下？

而SQL的例子没有保证任何特定的执行顺序，因为它也不在乎顺序是不是变了。但是假如查询是用命令式代码写的，数据库完全不能保证代码是不是依赖于特定的顺序。SQL在功能上更受限制的事实给了数据库更大的空间来追求自动优化。

最后，声明式语言往往更适合并行执行。今天，CPU通过添加更多核心变得更快，而不是通过运行在更高的核心频率上。命令式代码很难在多核心或多设备上并行处理，因为它声明了指令必须以特定顺序执行。声明式语言更有可能在并行执行时跑得更快，因为它只声明了结果的模式，而不是用来计算结果的算法。数据库在合适的时候可以任意选择查询语言的并行实现。
