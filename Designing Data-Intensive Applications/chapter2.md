# 第二章 数据模型与查询语言

*我的语言的界限就是我的世界的界限。*

路德维希·维特根斯坦，逻辑哲学论

数据模型也许是软件开发中最重要的部分了，因为它们有着最深刻的作用：不仅仅是关于软件要怎么写，更是关于我们如何思考我们要解决的问题。

大部分应用程序是通过数据模型层叠构建起来的。对于每一层来说核心问题是：它是如何用下一层术语*表现*的？举个例子：
1. 作为一个应用程序开发者，你看着真实世界（在其中有人、组织、物品、动作、资金流动、传感器等等）然后用对象或者数据结构对它建模，并构建操作这些数据结构的API。这些数据结构通常是特定于你的应用的。
2. 当你要存储这些数据结构，你用一种通用数据结构表达它们，比如JSON文档或者XML文档，关系型数据库中的表，亦或是一个图模型。
3. 构建你使用的数据库软件的工程师先前决定了JSON/XML/关系型/图型数据是如何用内存、硬盘或是网络上的字节流表现方式。
4. 在更低的层，硬件工程师已经想通了如何用电流、光脉冲、磁场来表现字节。

在一个复杂的应用中也许会存在更多的中间层，比如API构建在其它API之上，但是基本的想法仍然是一致的：每一层通过提供一个干净的数据模型隐藏其下层次的复杂性。这样的抽象允许不同的人群——比如，数据库供应商的工程师与使用数据库的应用程序工程师——有效地协作。

市面上有许多种不同的数据模型，且每一种数据模型都包含了如何使用它的假设。有一些用法很简单而有一些是不支持的；有一些操作是很快的而有一些执行起来很差；有一些数据转换很自然而有一些很别扭。

哪怕只是掌握一种数据模型也是会花费很大精力的（想想市面上有多少本关系型数据建模的书就可想而知了）。构建软件已经很困难了，哪怕只是使用一种数据模型并且不计较它的内部实现。但是由于数据模型对构建于其上的软件有着至深的影响，选择一个适合这个应用的就很重要了。

在这一章中我们将研究一系列针对数据存储与查询的通用数据结构（对应先前列表中的第2点）。特别的是我们将比较关系型、文档型以及一小部分基于图的数据结构。我们也将研究众多的查询语言并计较它们的使用场景。在第三章中我们将讨论存储引擎是如何工作的；也就是，这些数据模型实际中是如何实现的（对应先前列表中的第3点）。

## 关系型模型 vs 文档型模型

今天最为人所知的数据模型大概就是SQL了，基于1970年Edgar Codd建议的关系型模型：数据被组织为*关系*（在SQL中称为*表*），其中每一种关系都是一个*元组*的无序集合（在SQL中成为*行*）。

关系型模型是一个理论性建议，当时的许多人怀疑它能否有效率地实现出来。然而到了80年代中期，关系型数据库管理系统（RDBMSes）和SQL成为了大多数需要存储和查询某种规则结构的选择。关系型数据库称霸行业持续了25到30年——对于计算机历史来说这么长的时间就是永恒。

关系型数据库根源在于*业务数据处理*，在六七十年代主流计算机都在执行它。从今天的角度看这样的使用场景很平凡：一般是*交易处理*（输入销售数据或者银行交易、航班预订、货仓物管）和*批量处理*（客户发票、账单、报告）。

当时其它数据库强迫应用程序开发者考虑很多数据在数据库中的内部表现形式。关系型模型的目标则是隐藏这些实现细节，取而代之的是更加干净的接口。

这么多年以来，出现了许多与之竞争的数据存储与查询方式。七十年代到八十年代初，*网络模型*和*分层模型*是主要的备选方案，但是最终关系型模型还是主宰了市场。对象数据库在八十年代末九十年代初昙花一现。新世纪初又出现了XML数据库，但是只有少量的采用。关系型模型的竞争对手们在出现时都引起了不少炒作，但都没有持续很长时间。

随着计算机变得越来越强大并互相联网，使用场景也开始变得更加分散。值得骄傲的是，关系型数据库结果通用化做得非常好，它超越了最初只是进行业务数据处理的范围而扩展到了更广的使用场景中。许多现如今你看到的网络依旧是关系型数据库支撑的，比如在线出版、讨论、社交网络、电子商务、游戏、即需即用的效率型应用等等。

### NoSQL的诞生

如今，NoSQL是推翻关系型模型绝对统治力的最新一次尝试。这个名字相当不幸，因为实际上它并不指代任何特定的技术——最初只是在Twitter上为2009年的一次开源分布式非关系型数据库会议设计的主题标签，它很好记。然而，这个名字像发了疯一样迅速火遍了网络初创社区。今天一些有趣的数据库系统都打上了#NoSQL标签，而且重新解释成*不只是SQL*。

引入NoSQL数据库背后的驱动力有这么几个，包括：
* 需要一种比关系型数据库更容易达成的高扩展度，包括非常大的数据集或者非常高的写入吞吐量
* 相比于商业数据库软件，普遍偏向选择免费开源软件
* 关系型模型对特殊定制化的查询操作支持不佳
* 受限于关系型模式定义的严格，需要一种更动态和更有表达性的数据模型


### 对象-关系不匹配

今天大部分应用开发使用面向对象编程语言完成的，对SQL数据模型的批评由此引出：如果数据存储在关系型表里，那必然存在一个在程序代码与数据库模型（表、行、列）之间的尴尬转换层。这种模型之间无法衔接也被戏称为*阻抗不匹配*。

类似ActiveRecord和Hibernate这种对象关系映射框架减少了这一层必不可少的样板代码量，然而它们不可能完全的掩盖两种模型之间的差别。

举例来说，图2-1展示了一份简历（一份LinkedIn资料）是如何用关系型模式定义表达的。这份资料作为一个整体可以用一个唯一标识符标识，`user_id`。诸如`first_name`和`last_name`这样的字段每个用户只出现一次，所以它们可以被建模为`users`表中的列。然而，大多数人在他们的职业生涯中都做过超过一份工作（或职位），人们的受教育经历也不同数量的几段时间，联系方式也是类似。用户与这些项之间是一对多的关系，可以用很多种方式表达：
* 在传统SQL模型（SQL:1999之前），最常见的标准化表现形式是把职位、教育和联系方式存到不同的表里，用外键指向`users`表，如图2-1所示。
* 后续的SQL标准调价了对结构化数据类型和XML数据的支持；这允许多值数据可以存储在单行内，同时对这些文档支持查询和建立索引。Oracle、IBM DB2、MS SQL Server以及PostgreSQL对这些功能有着不同程度的支持。JSON数据类型也被少数几个数据库支持，包括IBM DB2、MySQL和PostgreSQL。
* 第三个选项是把工作、教育以及联系人信息编码为一个JSON或者XML文档，存在数据库的一个文本列内，让应用程序自己解析这个结构和内容。在这样的设置中，一般无法让数据库在编码后的列内进行查询。

对于类似简历这样的数据结构，大部分时候是一个独立的*文件*，用JSON表达是非常合适的：如示例2-1.相比于XML，JSON因为更简单于是更吸引人。类似MongoDB、RethinkDB、CouchDB以及Espresso这类面向文档的数据库支持这种数据类型。

*示例2-1 用JSON文档呈现一个LinkedIn资料*
```JSON
{
  "user_id":      251,
  "first_name":   "Bill",
  "last_name":    "Gates",
  "summary":      "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id":    "us:91",
  "industry_id":  131,
  "photo_url":    "/p/7/000/253/05b/308dd6e.jpg",
  "positions":    [
    {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
  ],
  "education":    [
    {"school_name": "Harvard University", "start": 1973, "end": 1975},
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ],
  "contact_info": {
    "blog":     "http://thegatesnotes.com",
    "twitter":  "http://twitter.com/BillGates"
  }
}
```
