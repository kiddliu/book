# 第二章 数据模型与查询语言

*我的语言的界限就是我的世界的界限。*

路德维希·维特根斯坦，逻辑哲学论

数据模型也许是软件开发中最重要的部分了，因为它们有着最深刻的作用：不仅仅是关于软件要怎么写，更是关于我们如何思考我们要解决的问题。

大部分应用程序是通过数据模型层叠构建起来的。对于每一层来说核心问题是：它是如何用下一层术语*表现*的？举个例子：
1. 作为一个应用程序开发者，你看着真实世界（在其中有人、组织、物品、动作、资金流动、传感器等等）然后用对象或者数据结构对它建模，并构建操作这些数据结构的API。这些数据结构通常是特定于你的应用的。
2. 当你要存储这些数据结构，你用一种通用数据结构表达它们，比如JSON文档或者XML文档，关系型数据库中的表，亦或是一个图模型。
3. 构建你使用的数据库软件的工程师先前决定了JSON/XML/关系型/图型数据是如何用内存、硬盘或是网络上的字节流表现方式。
4. 在更低的层，硬件工程师已经想通了如何用电流、光脉冲、磁场来表现字节。

在一个复杂的应用中也许会存在更多的中间层，比如API构建在其它API之上，但是基本的想法仍然是一致的：每一层通过提供一个干净的数据模型隐藏其下层次的复杂性。这样的抽象允许不同的人群——比如，数据库供应商的工程师与使用数据库的应用程序工程师——有效地协作。

市面上有许多种不同的数据模型，且每一种数据模型都包含了如何使用它的假设。有一些用法很简单而有一些是不支持的；有一些操作是很快的而有一些执行起来很差；有一些数据转换很自然而有一些很别扭。

哪怕只是掌握一种数据模型也是会花费很大精力的（想想市面上有多少本关系型数据建模的书就可想而知了）。构建软件已经很困难了，哪怕只是使用一种数据模型并且不计较它的内部实现。但是由于数据模型对构建于其上的软件有着至深的影响，选择一个适合这个应用的就很重要了。

在这一章中我们将研究一系列针对数据存储与查询的通用数据结构（对应先前列表中的第2点）。特别的是我们将比较关系型、文档型以及一小部分基于图的数据结构。我们也将研究众多的查询语言并计较它们的使用场景。在第三章中我们将讨论存储引擎是如何工作的；也就是，这些数据模型实际中是如何实现的（对应先前列表中的第3点）。

## 关系型模型 vs 文档型模型

今天最为人所知的数据模型大概就是SQL了，基于1970年Edgar Codd建议的关系型模型：数据被组织为*关系*（在SQL中称为*表*），其中每一种关系都是一个*元组*的无序集合（在SQL中成为*行*）。

关系型模型是一个理论性建议，当时的许多人怀疑它能否有效率地实现出来。然而到了80年代中期，关系型数据库管理系统（RDBMSes）和SQL成为了大多数需要存储和查询某种规则结构的选择。关系型数据库称霸行业持续了25到30年——对于计算机历史来说这么长的时间就是永恒。

关系型数据库根源在于*业务数据处理*，在六七十年代主流计算机都在执行它。从今天的角度看这样的使用场景很平凡：一般是*交易处理*（输入销售数据或者银行交易、航班预订、货仓物管）和*批量处理*（客户发票、账单、报告）。

当时其它数据库强迫应用程序开发者考虑很多数据在数据库中的内部格式。关系型模型的目标则是隐藏这些实现细节，取而代之的是更加干净的接口。

这么多年以来，出现了许多与之竞争的数据存储与查询方式。七十年代到八十年代初，*网络模型*和*分层模型*是主要的备选方案，但是最终关系型模型还是主宰了市场。对象数据库在八十年代末九十年代初昙花一现。新世纪初又出现了XML数据库，但是只有少量的采用。关系型模型的竞争对手们在出现时都引起了不少炒作，但都没有持续很长时间。

随着计算机变得越来越强大并互相联网，使用场景也开始变得更加分散。值得骄傲的是，关系型数据库结果通用化做得非常好，它超越了最初只是进行业务数据处理的范围而扩展到了更广的使用场景中。许多现如今你看到的网络依旧是关系型数据库支撑的，比如在线出版、讨论、社交网络、电子商务、游戏、即需即用的效率型应用等等。

### NoSQL的诞生

如今，NoSQL是推翻关系型模型绝对统治力的最新一次尝试。这个名字相当不幸，因为实际上它并不指代任何特定的技术——最初只是在Twitter上为2009年的一次开源分布式非关系型数据库会议设计的主题标签，它很好记。然而，这个名字像发了疯一样迅速火遍了网络初创社区。今天一些有趣的数据库系统都打上了#NoSQL标签，而且重新解释成*不只是SQL*。

引入NoSQL数据库背后的驱动力有这么几个，包括：
* 需要一种比关系型数据库更容易达成的高扩展度，包括非常大的数据集或者非常高的写入吞吐量
* 相比于商业数据库软件，普遍偏向选择免费开源软件
* 关系型模型对特殊定制化的查询操作支持不佳
* 受限于关系型模式定义的严格，需要一种更动态和更有表达性的数据模型


### 对象-关系不匹配

今天大部分应用开发使用面向对象编程语言完成的，对SQL数据模型的批评由此引出：如果数据存储在关系型表里，那必然存在一个在程序代码与数据库模型（表、行、列）之间的尴尬转换层。这种模型之间无法衔接也被戏称为*阻抗不匹配*。

类似ActiveRecord和Hibernate这种对象关系映射框架减少了这一层必不可少的样板代码量，然而它们不可能完全的掩盖两种模型之间的差别。

举例来说，图2-1展示了一份简历（一份LinkedIn资料）是如何用关系型模式定义表达的。这份资料作为一个整体可以用一个唯一标识符标识，`user_id`。诸如`first_name`和`last_name`这样的字段每个用户只出现一次，所以它们可以被建模为`users`表中的列。然而，大多数人在他们的职业生涯中都做过超过一份工作（或职位），人们的受教育经历也不同数量的几段时间，联系方式也是类似。用户与这些项之间是一对多的关系，可以用很多种方式表达：
* 在传统SQL模型（SQL:1999之前），最常见的标准化格式是把职位、教育和联系方式存到不同的表里，用外键指向`users`表，如图2-1所示。
* 后续的SQL标准调价了对结构化数据类型和XML数据的支持；这允许多值数据可以存储在单行内，同时对这些文档支持查询和建立索引。Oracle、IBM DB2、MS SQL Server以及PostgreSQL对这些功能有着不同程度的支持。JSON数据类型也被少数几个数据库支持，包括IBM DB2、MySQL和PostgreSQL。
* 第三个选项是把工作、教育以及联系人信息编码为一个JSON或者XML文档，存在数据库的一个文本列内，让应用程序自己解析这个结构和内容。在这样的设置中，一般无法让数据库在编码后的列内进行查询。

对于类似简历这样的数据结构，大部分时候是一个独立的*文件*，用JSON表达是非常合适的：如示例2-1.相比于XML，JSON因为更简单于是更吸引人。类似MongoDB、RethinkDB、CouchDB以及Espresso这类面向文档的数据库支持这种数据类型。

*示例2-1 用JSON文档呈现一个LinkedIn资料*
```JSON
{
  "user_id":      251,
  "first_name":   "Bill",
  "last_name":    "Gates",
  "summary":      "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id":    "us:91",
  "industry_id":  131,
  "photo_url":    "/p/7/000/253/05b/308dd6e.jpg",
  "positions":    [
    {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
  ],
  "education":    [
    {"school_name": "Harvard University", "start": 1973, "end": 1975},
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ],
  "contact_info": {
    "blog":     "http://thegatesnotes.com",
    "twitter":  "http://twitter.com/BillGates"
  }
}
```
一些开发者感觉JSON模型降低了应用代码与存储层之间的阻抗不匹配。然而，在第四章我们将看到，用JSON作为数据编码格式也是有问题的。模式定义的缺失经常被认为是一种优势；我们会在“文档模型中模式定义的灵活性”讨论它。

在图2-1中JSON格式相比于多表模式有着更好的*本地性*。如果尝试从一个关系型示例中获取一份资料，你要么执行多次查询（通过`user_id`查询每一张表），要么在`users`与相关表上执行一次复杂的连接。相比之下在JSON格式中，所有相关的信息都在一起，一次查询就足够了。

用户资料与用户的职位、受教育经历以及联系方式之间构成了数据间的树状结构，JSON格式把这种结构呈现了出来（见图2-2）。

### 多对一与多对多关系

在前一节的示例2-1中，`region_id`与`industry_id`被定义为ID，而不是纯文本字符串如“大西雅图地区”和“慈善事业”。为什么？

如果用户界面提供了文本框以接收用户输入的地区与行业，把他们存储为纯文本字符串也算合理。但是准备好二者的标准化列表，并允许用户从下拉菜单选择或者自动补全也有它的好处：
* 所有资料有着一致的风格与拼写
* 避免混淆（比如有许多城市有着一样的名字）
* 更新方便——名字都存储在一个地方，一旦出现变化（比如由于政治事件城市名字变了）很容易进行全面更新
* 本地化的支持——当望着被翻译成另外一种语言，这些标准化的列表也可以被翻译，从而地区与行业可以使用用户的语言显示
* 更好的搜索——比如，由于地区列表包含了西雅图位于华盛顿州这样的事实（如果是字符串“大西雅图地区”就没有这么明显了），于是搜索华盛顿州的慈善家可以定位到这份资料

是存成一个ID还是一个字符串这是一个关于重复的问题。当你使用ID，那些对人们有意义的信息（比如*慈善家*这个词）只储存在一个位置，所有指向这个信息的地方都用ID代替（这只在数据库中是有意义的）。当你直接存储字符串的时候，所有使用它的地方都在重复着这些信息。

使用ID的优势在于它对于人是没有意义的，它本身不需要改变：哪怕它指向的信息变了，ID是可以保持不变的。而任何对于人有意义的事物将来都有可能会变——一旦这些信息被复制了，所有多余的拷贝都需要跟着更新。这导致了写入的开销，以及信息不一致的风险（有些拷贝更新了而有些没有）。移除这样的重复信息是数据库规范化的核心理念。

> #### 注意
数据库管理员与开发者之间喜欢争论规范化与去规范化，但是我们将暂时暂停这种争论。在本书的第三部分我们将会回到这个话题上来，研究应对缓存、去规范化以及衍生数据的系统化方式。

然而不幸的是，规划化这样的数据需要*多对一*关系（例如许多人住在同一个特定地区，许多人在同一个特定行业工作），放在文档模型中不是很合适。在关系型数据库中，通过ID指向其它表中的行是很平常的，因为连接很简单。在文档型数据库中，一对多的树状结构并不必要连接，因此连接的支持通常很差。

如果数据库本身不支持连接，你就必须在应用程序代码中通过多次查询数据库模拟它。（在这种情况下，地区与行业列表大概会很小，变化也很慢从而应用可以把他们存在内存中。但是不管怎样，进行连接的工作从数据库转到了应用程序代码。）

此外，哪怕应用的最初版本适配了没有连接支持的文档模型，数据总会由于功能的不断添加变得互相联系起来。举个例子，考虑一下我们可以对简历这个例子做某些变化：

*作为实体的组织与学校*

在之前的描述中，`organization`（用户曾经工作过的公司）与`school_name`（他们学习的地方）只是字符串。也许它们应该指向某些实体？那么每一个组织、学校或者大学可以有各自的网页（包括徽标、新闻摘要等）；每一份简历都可以链接到提及的组织与学校，包括他们的徽标以及其它信息（详见图2-3中来自LinkedIn的一个例子）。

*推荐信*

假如你想添加一个新功能：用户可以写推荐信给另外一个用户。推荐信会被显示在被推荐人的简历上，外加推荐人的姓名和照片。如果推荐人更新了自己的照片，他们写过的推荐信都需要更新。因而，推荐信应该有一个指向作者资料的链接。

图2-4展示了新需求需要的多对多关系。点线框内的数据可以被划为一组构成一个文档，但是指向组织、学校以及其它用户的链接将被定义为引用，查询时需要用到连接。
