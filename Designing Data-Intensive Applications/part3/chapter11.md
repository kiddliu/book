# 第十章 流处理

*一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。*

约翰·盖尔，*系统学*（1975）

---

在第10章中，我们讨论了批处理——这是读取一组文件作为输入并生成一组输出文件的技术。输出是*衍生数据*的一种形式；也就是说，如果有必要，可以通过再次运行批处理过程重新创建的数据集。我们看到了如何使用这个简单而强大的想法来创建搜索索引、推荐系统、分析等等。

然而一个大前提贯穿整个第10章：即，输入是有界的——即已知且有限的大小——因此批处理过程知道它什么时候完成了对输入的读取。例如，位于MapReduce核心位置的排序操作必须先读取整个输入，然后才能开始产生输出：可能会发生最后一个输入记录按键排序值最小的情况，因此它就是是第一条输出记录，所以不可能提早启动输出。

实际上许多数据是没有限制的，因为它是随着时间的推移逐渐到达的：你的用户昨天和今天产生了数据，他们明天会继续生成更多的数据。除非你退出业务，否则这个过程永远没有尽头，因此数据集永远不会以任何有意义的方式“完成”。因此，批处理程序必须人为地把数据按固定时间间隔划分成块：例如，在每天结束时处理一天的数据值，或在每小时结束时处理这一小时的数据。

日常批处理遇到的问题是，输入的更改只会在一天之后的输出中反映出来，这对于许多不耐烦的用户来说太慢了。为了减少延迟，我们可以更频繁地运行处理——比如说，在每秒结束时处理一秒钟的数据——甚至是连续地处理，完全放弃固定的时间片而只处理发生的每一个事件。这就是*流处理*背后的理念。

一般来说，“流”指的是随着时间的推移逐渐可用的数据。这个概念出现在许多地方：在Unix的`stdin`和`stdout`中，编程语言（惰性列表）、文件系统API（例如Java的`FileInputStream`）、TCP连接、通过互联网发送音频视频等等。

在本章中，我们将把*事件流*看作一种数据管理机制：与我们在上一章中看到的批处理数据进行无界、增量处理的对应。我们首先会讨论如何在网络上表示、存储和传输流。在“数据库和流”一节中，我们将研究流和数据库之间的关系。最后，在“流的处理”一节中，我们会探索持续处理这些流的方法和工具，以及它们可用于构建应用程序的方法。