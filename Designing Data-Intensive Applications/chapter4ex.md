最后，Protocol Buffers（只有一种二进制编码格式）编码同样的数据如图4-4所示。它做打包位的方式有些许不同，但是与Thrift的CompactProtocol非常类似。Protocol Buffers用了33个字节编码了同样的条目。

*图4-4 用Protocol Buffers编码示例条目*

注意一个细节：早先展示的模式定义中，每个字段都标记了`required`或者`optional`，但是这不影响字段是如何编码的（二进制数据中没有办法表示一个字段是否为必须的）。区别只是在于`required`可以启动运行时检查，如果字段没有设置将会失败，方便捕获bug。

#### 字段标签与模式定义演进

我们之前说，模式定义无法避免地随着时间推移需要变更。我们把这叫做模式定义演进。Thrift与Protocol Buffers是如何处理模式定义变更且同时保持向后以及向前兼容地呢？

正如之前例子看到的，编码后的记录只是编码后字段的连接。每个字段通过它的标签号码标记（示例模式定义中的数字1，2，3）并用数据类型标注（例如字符串或者整型数）。如果一个字段值没有设，它只是简单地被编码后的条目忽略了。从这里你可以看出字段标签对于编码后数据的含义至关重要。你可以在模式定义中改变一个字段的名字，毕竟编码后的数据从不引用字段名字，但是你不能改变一个字段的标签，因为这将使得所有已经存在的编码后数据无效。

你可以添加新的字段到模式定义中，前提是你给每一个字段一个新的标签号码。如果旧代码（不知道你添加的新标签好吗）尝试读取新代码写入的数据，其中包含它不能识别的标签号码对应的字段，它可以简单地忽略那个字段。数据类型标记允许解析器判定多少字节需要忽略。这保持了向前兼容性：旧代码可以读取新代码写入的数据。

那么向后兼容性呢？只要每一个字段都有一个唯一的标签号码，新代码就总可以读取旧数据，因为标签号码依旧有相同的含义。唯一的细节在于如果你添加一个新字段，你无法要求它是强制的。否则，强制检查会失败，因为就代码不会写你新添加的字段。因而为了保持向后兼容性，每个模式定义初次部署之后添加的字段都必须是可选的，或者必须有默认值。

删除字段与添加字段类似，只是向前向后兼容性考虑反过来了。这意味着你只可以移除可选字段（强制字段不能被移除），也用用不能再使用同一个标签号码（因为有可能还有某处的数据包含旧的标签号码，而新代码必须忽略这个字段）。

#### 数据类型与模式定义演进

那改变字段的数据类型呢？这是由可能的——检查说明文档获取详细信息——但是有值丢失精度或者被截断的风险。举个例子，假设你把32位整型数变为64位整型数。新的代码可以很容易地读取旧代码写入地数据，因为解析器可以在缺失的位填入零。然而，如果就代码读取新代码写入的数据，旧代码仍然用32位变量储存值。如果解码后的64位值用32位放不下，它就会被截断了。

Protocol Buffers一个奇怪的细节是它没有链表或者数组数据类型，取而代之的是一个字段的`repeated`标记（它是与`required`和`optional`平齐的第三选项）。如你在图4-4中看到的，`repeated`字段的编码正如它的字面意思：条目中同一个字段标签出现了多次。这样做有一个不错的效果，就是可以把`optional`（单值）字段变成一个`repeated`（多值）字段。新代码读取旧数据看到的是一个有着零或一个元素的链表（取决于字段是否出现）；旧代码读取新数据只看到链表的最后一个元素。

Thrift有专门的链表数据类型，它可以被链表元素的数据类型参数化。类似Protocol Buffers的单值到多值演化是不允许的，但是它有它的优势：支持嵌套的链表。

### Avro