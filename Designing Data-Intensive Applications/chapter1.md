# 第一章 可靠的、可扩展的、可维护的应用程序

*Internet是如此得成功以至于绝大多数人们以为它就像太平洋一样是一种自然资源，而不是人们动手建立起来的。上一次出现这种有着如此规模却又近乎完美的技术是什么时候来着？*

摘自Alan Kay在2012年Dr Dobb期刊中的访谈

今天许多的应用程序不是*计算集约*而是*数据集约型的*了。对于这些应用程序，CPU的性能很少是瓶颈了——更大的问题是数据的数量、数据的复杂度以及数据变化的速度。

一个数据集约型的应用程序通常由满足一般性需求功能的标准构建模块构建的。举个例子来说，许多应用程序都需要：
* 存储数据从而它们自己，或者其他应用程序可以稍后使用（数据库）
* 存储代价高的运算结果，从而提升访问速度（缓存）
* 允许用户通过各种方式进行关键词搜索或者过滤（搜索索引）
* 向其它进程发送消息，进行异步处理（流处理）
* 周期性的处理大量的累积数据（批处理）

如果这些都听起来相当的显而易见，这正是因为这些*数据系统*是一种成功的抽象：我们一直使用着它们却没有思考太多。构建应用程序的时候，绝大部分工程师不会想着从头开始写一个新的数据存储引擎，毕竟数据库是可以完美胜任这项工作的。

但是现实可没有这么简单。因为不同的应用程序有着不同的需求，于是也就有了许多特性各不相同的数据库系统。同样也有许多种方式实现缓存，简历搜索索引，等等等等。构建应用程序的时候，我们仍然需要搞清楚哪些工具、哪些解决方式对于手边的任务是最合适的。当单一工具无法解决问题的时候，组合不同的工具本身就是难题。

这本书既讨论数据系统的原则也讨论实用性的问题，以及你可以如何使用它们来构建数据集约型的应用程序。我们将探索不同工具之间的共性、差别、以及它们是如何实现不同特性的。

在这一章的开始，我们将探索我们尝试实现的可靠的、可扩展的、可维护的数据系统
的基础部分。我们将阐明它们的含义，提炼一些思考它们的方式，并对后续章节用到的基础知识一一复习。而在稍后几章我们将逐一解析在设计数据集约型应用时那些需要考虑到的设计决定。

## 想想数据系统

我们通常认为数据库、队列、缓存等等是非常不同类别的工具。虽然表面上数据库与消息队列有一些类似——两者都在一段时间内储存数据——然而它们有着非常不同的访问模式，这意味着非常不同的性能特性，并因此有着非常不同的实现。

那我们为什么要把它们都归结为*数据系统*呢？

最近一些年出现了许多新的数据存储与处理工具。它们针对各种各样不同的用例优化，而不再适合归结为传统的一类。比如说，现在有了也可以用作消息队列的数据存储（Redis），也有了类似数据库一样持久性保证的消息队列（Apache Kafka）。这些类别之间的边界渐渐模糊起来。

其次，越来越多的应用程序现在有着越来越多越来越广的需求，以至于单一工具不再能满足所有的数据处理以及储存需求。取而代之的是这些工作被拆分成了许多小任务，每一个任务都*能*被单一工具有效的处理，而应用程序代码把这些工具连在了一起。

假如说你有一个应用程序管理的缓存层（借助Memcached或者类似工具），或者一个与主数据库分离的全文搜索服务器（比如Elasticsearch或者Solr），一般地保证缓存、索引与主数据库同步是应用程序代码的责任。图1-1大致给出了这也许是什么样的（我们会在稍后章节详细讨论）
